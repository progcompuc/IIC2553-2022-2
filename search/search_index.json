{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Informaci\u00f3n B\u00e1sica","text":""},{"location":"#clases","title":"Clases","text":"<p>Horario: 14:00-18:30</p> <p>Sala Javier Pinto, DCC (4to piso Edificio San Agust\u00edn, el primero a mano derecha desde el metro)</p>"},{"location":"#profesor","title":"Profesor","text":"<p>Pablo Messina (pamessina@uc.cl)</p>"},{"location":"#ayudante","title":"Ayudante","text":"<p>Mat\u00edas Fern\u00e1ndez (matias.fernandez@uc.cl)</p>"},{"location":"#telegram-del-curso-medio-oficial-de-comunicacion","title":"Telegram del curso (medio oficial de comunicaci\u00f3n)","text":"<p>Unirse </p>"},{"location":"#spreadsheet-de-notas-y-asistencia","title":"Spreadsheet de notas y asistencia","text":"<p>Ver spreadsheet </p>"},{"location":"ethics/","title":"\u00c9tica e Integridad Acad\u00e9mica","text":""},{"location":"ethics/#tldr","title":"TL;DR","text":"<ol> <li>You shall not copy-paste c\u00f3digo ajeno (hay penas del infierno por hacer esto).</li> <li>Por un tema pedag\u00f3gico, siempre intenta hacer los problemas por ti mism@ primero. No obstante, si sientes que se est\u00e1 poniendo muy complicada la cosa, tenemos varios tips sobre c\u00f3mo recibir apoyo/ayuda sin salirse de los m\u00e1rgenes de la \u00e9tica (ver detalles abajo).</li> </ol>"},{"location":"ethics/#detalles","title":"Detalles","text":"<p>Puedes hacer uso de recursos en l\u00ednea al resolver problemas. Esto incluye documentaci\u00f3n de tu lenguaje de programaci\u00f3n favorito, descripciones de algoritmos, implementaciones est\u00e1ndar de ciertos algoritmos y estructuras de datos como referencia, wikipedia, youtube, libros, tutoriales, etc. Es m\u00e1s, en caso de desesperaci\u00f3n en este curso est\u00e1 incluso permitido consultar soluciones de ejemplo. Sin embargo, LA COPIA DESCARADA DE SOLUCIONES AJENAS est\u00e1 terminantemente PROHIBIDA. Por favor, NUNCA hagas copy paste de c\u00f3digos ajenos. La idea del curso es que aprendas a programar tus propias soluciones, y hacer copy paste sabotea completamente dicho prop\u00f3sito. Para evitar pasar malos ratos, nuestra recomendaci\u00f3n al enfrentar problemas es la siguiente:</p> <ol> <li> <p>Primero intenta resolver los problemas por ti mism@, trata de no usar ning\u00fan recurso externo excepto por quiz\u00e1 documentaci\u00f3n del lenguaje de programaci\u00f3n que est\u00e1s usando (por ej. si se te olvid\u00f3 c\u00f3mo se usaba cierta cosa de la librer\u00eda est\u00e1ndar)</p> </li> <li> <p>Si un problema est\u00e1 muy dif\u00edcil, intenta cambiarte a otro problema m\u00e1s f\u00e1cil (puedes ver los problemas m\u00e1s resueltos en el scoreboard, probablemente son los m\u00e1s f\u00e1ciles).</p> </li> <li> <p>Eventualmente si llegas a un punto en que te sientes pegad@ con todos los problemas que quedan, entonces es tiempo de pedir ayuda. Tanto el profesor como el ayudante estamos a tu disposici\u00f3n para ayudarte en cualquier tipo de duda que tengas, te\u00f3rica, de c\u00f3digo, alg\u00fan bug, lo que sea. Estamos disponibles 24/7/365. Puedes hacernos preguntas por el telegram del curso, chateando uno-a-uno con nosotros por telegram, etc. Adem\u00e1s de nosotros, tambi\u00e9n hay hartas personas con experiencia en progcomp que te pueden ayudar. Si tienes una duda y la planteas abiertamente en el Telegram del curso, todos podremos ayudarte y quiz\u00e1s tu duda le sirva alg\u00fan otr@ compa\u00f1er@ que tenga la misma duda.</p> </li> <li> <p>Si lo anterior no es suficiente, tambi\u00e9n puedes googlear explicaciones te\u00f3ricas (palabras) en internet. Tambi\u00e9n puedes consultar material de estudio, c\u00f3digos de estructuras de datos y algoritmos est\u00e1ndar, etc. Si haces esto, por favor incluye las referencias (links) en tu c\u00f3digo, explicando qu\u00e9 fuentes consultaste y en qu\u00e9 te ayudaron.</p> </li> <li> <p>Si las explicaciones te\u00f3ricas y recursos est\u00e1ndar de referencia no son suficientes, como medida de desesperaci\u00f3n y \u00faltimo recurso te est\u00e1 \u00e9ticamente permitido mirar soluciones ajenas de ejemplo, pero bajo la condici\u00f3n de que por ning\u00fan motivo hagas copy-paste. Esto incluye tanto las soluciones de ejemplo subidas por nosotros (staff) como las soluciones que googlees por tu cuenta de internet. Cualquiera sea el caso, si tomas la decisi\u00f3n de mirar soluciones ajenas, debes referenciar los c\u00f3digos que miraste, dejando bien claro en qu\u00e9 te ayudaron (qu\u00e9 fue lo que entendiste o aprendiste del c\u00f3digo ajeno que consultaste, quiz\u00e1s aprendiste una t\u00e9cnica de programaci\u00f3n que no se te hab\u00eda ocurrido antes?) y dejando bien claro que tu c\u00f3digo NO es un copy-paste del c\u00f3digo ajeno.</p> </li> <li> <p>Finalmente, ten presente que vjudge.net le otorga al autor de un contest acceso a las soluciones de los participantes ... S\u00ed, tanto el profesor como el ayudante tenemos acceso a sus c\u00f3digos. Si alguien misteriosamente resuelve un problema dif\u00edcil, tenga la seguridad de que con probabilidad muy alta su c\u00f3digo ser\u00e1 examinado por nosotros :)</p> </li> </ol> <p>Si llegamos a descubrir una copia, el  castigo consistir\u00e1 en lo siguiente:</p> <p>1) Primera copia: nota_final \\(= \\max(\\min(\\operatorname{Nota}_{V3}, 7) - 3, 1)\\)</p> <p>2) Segunda copia: nota_final \\(= 1 +\\) causal de eliminaci\u00f3n</p> <p>3) Tercera copia: exilio</p>"},{"location":"help/","title":"Auxilio, estoy pegad@, no s\u00e9 resolver un problema, no se me ocurre, no s\u00e9 implementarlo, \u00bfqu\u00e9 puedo hacer?","text":"<p>En programaci\u00f3n competitiva es normal encontrarse con problemas fuera de nuestra zona de comfort, problemas que nos superan, que nos frustran y que inclusive llegan hasta deprimirnos. Problemas que nos hacen decir \"Oh, y ahora qui\u00e9n podr\u00e1 .. ayudarme?\". Para esos programadores y programadoras desamparad@s hay buenas noticias: \u00a1existen muchas formas de recibir ayuda!</p> <p>Primero que todo, est\u00e1n los talleres presenciales (3 m\u00f3dulos los d\u00edas viernes). Tanto el profesor como el ayudante estaremos f\u00edsicamente ah\u00ed presentes para que nos bombardeen con preguntas [UPDATE COVID: remotamente presentes en Telegram / Discord / Zoom / etc.]. Tanto c\u00f3digo como teor\u00eda, lo que sea. No tengan miedo, pregunten. Del mismo modo, tambi\u00e9n est\u00e1n sus compa\u00f1er@s. En un curso siempre hay alumn@s m\u00e1s experimentad@s que sobresalen. Aprovechenl@s y h\u00e1ganles preguntas. Conversen. No es necesario estar toda la clase callad@ sin interactuar con nadie. La idea es que aprovechen la instancia presencial para discutir sobre los problemas con sus compa\u00f1er@s y con el staff del curso.</p> <p>Sin embargo, sabemos que la timidez es un problema y no tod@s se sienten c\u00f3mod@s preguntando en persona, por lo cual tambi\u00e9n existen alternativas de ayuda remota:</p> <ul> <li>Telegram. Pueden hacer preguntas en el grupo de Telegram del curso. Si necesitan una ayuda m\u00e1s personalizada, Telegram tambi\u00e9n permite chatear directamente con personas (1 a 1), ya sea con el profesor, el ayudante o incluso con sus otros compa\u00f1er@s m\u00e1s experimentad@s.</li> <li>Hints, explicaciones y soluciones de ejemplo. Todas las semanas tanto el profesor como el ayudante estaremos publicando hints, explicaciones y soluciones (c\u00f3digo) de ejemplo para la mayor\u00eda de los problemas de las competencias. Les iremos avisando de esto a lo largo del semestre.</li> <li>La p\u00e1gina del curso (i.e. esta p\u00e1gina), y en general, internet: Si te gusta m\u00e1s estudiar por cuenta propia, en esta p\u00e1gina encontrar\u00e1s mucho material de estudio disponible sobre distintos temas (adem\u00e1s de todo lo que puedas encontrar por tu cuenta en internet).</li> </ul>"},{"location":"tips/","title":"Tips para novat@s","text":""},{"location":"tips/#sobre-lenguajes-de-programacion","title":"Sobre lenguajes de programaci\u00f3n","text":"<p>En programaci\u00f3n competitiva el lenguaje m\u00e1s utilizado por lejos es C++ (y dentro de C++ generalmente se usa de C++11 para arriba). En segundo lugar se encuentra Java. Y hace muy poco se comenz\u00f3 a utilizar tambi\u00e9n Python. Sin embargo, lamentablemente la mayor\u00eda de los jueces online (los servidores que tienen los enunciados de los problemas y ejecutan los c\u00f3digos enviados por la gente) est\u00e1n calibrados generalmente para aceptar soluciones en C++, y a veces pasa que las soluciones en Python fallan con el famoso Time Limit Exceeded (TLE), debido a que Python por ser un lenguaje interpretado se ejecuta m\u00e1s lento que lenguajes compilados a c\u00f3digo de m\u00e1quina como C++. Adem\u00e1s, la mayor\u00eda de los c\u00f3digos de ejemplo disponibles en internet para progcomp est\u00e1n en C++ o quiz\u00e1 Java. Por este motivo, el consejo t\u00edpico es aprender C++. Si te motivas a seguir este consejo, en la secci\u00f3n para aprender C++ puedes encontrar bastante material para aprender. Dicho esto, que esto por favor no se malinterprete como que usar C++ es una obligaci\u00f3n. No, no. Si lo deseas, puedes usar Python, no hay ning\u00fan problema con eso. De hecho en muchos problemas las restricciones de tiempo son suficientemente holgadas y usar Python es perfectamente v\u00e1lido.</p> <p>El objetivo de este comentario es simplemente hacerte conciente de que al usar Python existe cierto riesgo de TLE por jueces \"pesados\" con restricciones de tiempo muy estrictas, y tambi\u00e9n que C++ es por lejos el lenguaje m\u00e1s popular en programaci\u00f3n competitiva. Si decides aprender C++, nuestro consejo es que vayas aprendiendo poco a poco, sin estresarte. Por ejemplo puedes ir intercalando entre C++ y Python. O puedes programar una soluci\u00f3n en Python y despu\u00e9s traducirla a C++, etc. Adem\u00e1s siempre estaremos subiendo ejemplos de soluciones en C++, y tanto el profesor como el ayudante estaremos disponibles para que nos hagas todas las consultas que necesites.</p>"},{"location":"tips/#sobre-restricciones-de-tiempo-y-memoria-en-programacion-competitiva","title":"Sobre restricciones de tiempo y memoria en programaci\u00f3n competitiva","text":"<ul> <li>En la ICPC y en la mayor\u00eda de los jueces online de entrenamiento los problemas tienen l\u00edmites de tiempo (ej. 3 segundos) y memoria (ej. 256 MB). Esto significa que soluciones muy lentas o soluciones que requieren anotar demasiadas cosas no funcionar\u00e1n.</li> <li>En C++ pueden hacerse un poco m\u00e1s de \\(10^8\\) operaciones baratas por segundo (una estimaci\u00f3n bien al ojo por experiencia con diferentes jueces online). Por lo tanto, si les dan \\(K\\) segundos de tiempo l\u00edmite, a lo m\u00e1s podr\u00e1n hacer un poco m\u00e1s de \\(K \\cdot 10^8\\) operaciones baratas. Tengan esto muy presente.</li> <li>MUY IMPORTANTE: ANTES DE TOCAR EL TECLADO, ANTES DE ESCRIBIR LA PRIMERA L\u00cdNEA DE C\u00d3DIGO, es sumamente importante estimar cu\u00e1nto se va a demorar la estrategia/algoritmo que quiero programar. Nadie quiere desperdiciar su tiempo programando una soluci\u00f3n que despu\u00e9s es muy lenta y nos da TLE (Time Limit Exceeded). Es por esto que siempre deben estimar la complejidad computacional de su algoritmo y evaluarla en el caso borde m\u00e1s grande (peor caso). Por ejemplo, si un problema depende de \\(N\\) donde \\(1 \\leq N \\leq 10^5\\) y mi algoritmo es cuadr\u00e1tico (complejidad \\(= \\mathcal{O}(N^2)\\)), entonces en el peor caso har\u00e9 \\((10^5)^2 = 10^{10}\\) operaciones, y por ende seg\u00fan el punto anterior necesitar\u00eda 100 segundos para correrlo. En cambio, si mi algoritmo tiene complejidad \\(\\mathcal{O}(N\\cdot\\log(N))\\) entonces en el peor caso s\u00f3lo har\u00e9 \\(10^5 \\cdot \\log(10^5) = 1.7 \\cdot 10^6\\) operaciones (aprox.), y por ende s\u00f3lo necesitar\u00eda \\(0.017\\) segundos (la nada misma) para correrlo. Entonces, si mi problema tiene un tiempo m\u00e1ximo de ejecuci\u00f3n de 2 segundos, \u00bfqu\u00e9 algoritmo va a funcionar? Claramente el segundo.</li> <li>Si van a usar mucha memoria, preoc\u00fapense de no pasarse del l\u00edmite de memoria permitido. Por ejemplo si les dan 256MB de memoria, en bytes eso es \\(256 \\cdot 1024 \\cdot 1024 = 268435456\\) bytes, un int32 ocupa 4 bytes, as\u00ed que como m\u00e1ximo podr\u00edan crear un arreglo de int32 de largo \\(67108864 = 6.7 \\cdot 10^7\\) aprox (o la mitad si usan un int64, un double, etc.). Tambi\u00e9n podr\u00eda acab\u00e1rseles la memoria si hacen demasiadas llamadas recursivas [1, 2].</li> </ul>"},{"location":"about/grading/","title":"C\u00e1lculo de la Nota Final","text":"<ul> <li>Sea \\(P_i =\\) total puntos por problemas resueltos dentro de plazo en el contest \\(i\\)-\u00e9simo</li> <li>Sea \\(T_i =\\) total puntos por problemas resueltos fuera de plazo en el contest \\(i\\)-\u00e9simo</li> <li>Sea \\(M_i =\\) puntaje m\u00ednimo esperado para el contest \\(i\\)-\u00e9simo</li> <li>Sea \\(A_i = 1\\) si viniste a clases para el contest \\(i\\)-\u00e9simo, \\(0\\) si no</li> <li>Sea \\(N =\\) n\u00famero de contests</li> </ul> <p>As\u00ed, se calcula:</p> <ul> <li>\\(D_i = \\max(M_i - P_i, 0) =\\) deuda de puntaje del contest \\(i\\)-\u00e9simo</li> <li>\\(PA_i = 3\\) si vienes a clase, \\(\\max(0, \\min(3, P_i - M_i))\\) si no vienes</li> <li>\\(E_i = \\max(P_i - M_i, 0) + T_i - (1-A_i) \\cdot PA_i =\\) excedente de puntaje del contest \\(i\\)-\u00e9simo, considerando posible descuento por inasistencia</li> <li>\\(X_i = 1 - \\frac{D_i}{M_i} =\\) fracci\u00f3n completada del m\u00ednimo esperado para el contest \\(i\\)-\u00e9simo</li> <li>\\(D =\\) suma de todos los \\(D_i\\)</li> <li>\\(E =\\) suma de todos los \\(E_i\\)</li> <li>\\(X =\\) promedio de todos los \\(X_i\\)</li> <li>\\(A = \\frac{\\min(1, \\sum PA_i)}{(3 \\cdot (N-2))}\\), el \\(-2\\) considera dos d\u00edas de inasistencia perdonados</li> </ul> <p>As\u00ed, \\(E\\) se usa para reducir la deuda \\(D\\) de la siguiente manera:</p> <ul> <li>\\(D' = \\max(D - E \\cdot 0.3, 0)\\)</li> <li>\\(X' = X + (1-X) \\cdot \\frac{(D-D')}{D}\\)</li> </ul> <p>As\u00ed, se obtiene una nota preliminar</p> <ul> <li>\\(\\operatorname{Nota}_{V1} = (1 + 6 \\cdot X') \\cdot 0.75 + (1 + 6 \\cdot A) \\cdot 0.25\\)</li> </ul> <p>Sin embargo, luego se bajar\u00e1 la escala del curso, es decir, si ning\u00fan alumno alcanz\u00f3 el \\(7\\), el alumno con mayor nota quedar\u00e1 con \\(7\\) (siempre y cuando la escala baje \"poco\" - i.e. habr\u00e1 un l\u00edmite para bajar la escala con el fin de prevenir \"hacks\" al sistema).</p> <ul> <li>\\(\\operatorname{Nota}_{V2} =\\) aplicar_escala_reducida(\\(\\operatorname{Nota}_{V1}\\))</li> </ul> <p>Luego se calcula las d\u00e9cimas de bonus efectivas:</p> <ul> <li>\\(B = (BCpp + BRPC + BCI) \\cdot \\frac{(\\operatorname{Nota}_{V1} - 1)}{6}\\)</li> </ul> <p>Finalmente, la nota final est\u00e1 dada por:</p> <ul> <li>\\(\\operatorname{Nota}_{V3} = \\operatorname{Nota}_{V2} + B\\)</li> </ul> <p>Todo lo anterior se encuentra formalizado en el spreadsheet de notas y asistencia: link</p>"},{"location":"about/how_course_works/","title":"C\u00f3mo funciona el curso","text":""},{"location":"about/how_course_works/#1-competencias-semanales","title":"1) Competencias Semanales","text":"<p>Este curso es 100% pr\u00e1ctico. La nota final depender\u00e1 de la resoluci\u00f3n por parte del alumno de problemas de programaci\u00f3n competitiva. Cada semana se publicar\u00e1 un contest (o competencia, en espa\u00f1ol). Los contests se caracterizan por lo siguiente:</p> <ul> <li> <p>Se publicar\u00e1n en vjudge.net, un sitio web que permite crear competencias utilizando problemas obtenidos de m\u00faltiples jueces online, con un scoreboard que se actualiza en tiempo real a medida que los participantes resuelven problemas. Para competir es necesario que te crees una cuenta en vjudge.net y posteriormente que te unas con dicha cuenta a los contests a medida que estos vayan siendo publicados.</p> </li> <li> <p>A menos que se indique lo contrario, todas las competencias ser\u00e1n individuales. Excepcionalmente, hacia el final del semestre es posible que una que otra competencia sea de car\u00e1cter grupal, con un m\u00e1ximo de 3 integrantes por grupo (esto ser\u00e1 avisado si se llega a realizar).</p> </li> <li> <p>En general los contests ser\u00e1n tem\u00e1ticos. Es decir, cada contest estar\u00e1 compuesto por problemas que se resuelven utilizando estrategias pertenecientes a una categor\u00eda o tema com\u00fan (ej. fuerza bruta, geometr\u00eda, grafos, strings, etc.). El tema del contest se avisar\u00e1 con anticipaci\u00f3n junto con una recomendaci\u00f3n de material de estudio que los alumnos podr\u00e1n revisar antes de la clase.</p> </li> <li> <p>En general el primer m\u00f3dulo de cada clase (14:00 - 15:30) ser\u00e1 de c\u00e1tedra. La idea es revisar contenidos relevantes para el contest de la semana. Esto significa revisar la teor\u00eda, ver c\u00f3digos de ejemplo y quiz\u00e1 explicar la soluci\u00f3n de alg\u00fan problema que aparecer\u00e1 en el contest. Tambi\u00e9n es muy com\u00fan discutir soluciones de problemas del contest pasado en este bloque.</p> </li> <li> <p>El resto de la clase (15:30 en adelante) es pr\u00e1ctico. La idea es que durante los dos m\u00f3dulos restantes los alumnos trabajen en sus computadores programando. Por esto se recomienda que cada uno traiga su laptop a la clase. Si no tienes laptop, por favor avisa al staff del curso con anticipaci\u00f3n para poder coordinar laptops de repuesto. [Nota COVID: esto, obviamente, no aplica en formato de clase remoto]</p> </li> <li> <p>Salvo en contest grupales, cada alumn@ debe programar su propia soluci\u00f3n. Copiar c\u00f3digo ajeno est\u00e1 terminantemente prohibido. Sin embargo, s\u00ed est\u00e1 permitido conversar sobre los problemas, compartir ideas y discutir posibles soluciones con sus compa\u00f1er@s. Adem\u00e1s, tanto el profesor como el ayudante estamos disponibles para atender sus dudas y preguntas sobre los problemas, sobre c\u00f3digo, sobre teor\u00eda, etc.</p> </li> <li> <p>Los problemas de cada contest tendr\u00e1n diferentes niveles de dificultad, algunos problemas son m\u00e1s f\u00e1ciles y otros m\u00e1s dif\u00edciles. Por ende, cada problema tendr\u00e1 asociado un puntaje seg\u00fan su nivel de dificultad, y los puntos que obtengas en el contest ser\u00e1n la suma de los puntos de los problemas que resuelvas. Estos puntajes se mantendr\u00e1n intencionalmente ocultos por un par de d\u00edas luego de iniciado el contest :)</p> </li> <li> <p>Puntajes: regalado (1), f\u00e1cil (2), medio-f\u00e1cil (3), medio (4), medio-dif\u00edcil (5), dif\u00edcil (6), muy dif\u00edcil (7), demasiado dif\u00edcil (8 o m\u00e1s)</p> </li> <li> <p>Cada contest tendr\u00e1 un puntaje m\u00ednimo esperado, si en el contest logras un puntaje \\(\\geq\\) a dicho m\u00ednimo obtienes un 100% de completado en el contest, de lo contrario obtienes un porcentaje inferior y una deuda de puntaje. Todas las deudas de puntaje de todos tus contests se suman y conforman tu deuda de puntaje total. No obstante, si tu puntaje para un contest supera el m\u00ednimo esperado, se genera un excedente de puntaje, y del mismo modo todos tus excedentes se suman y conforman tu excedente de puntaje total. Como es de esperar, el excedente de puntaje te puede ayudar a compensar tu deuda de puntaje y subir tu nota, aunque ten en cuenta que el excedente de puntaje es multiplicado por un coeficiente de 0.3.</p> </li> <li> <p>vjudge permite enviar soluciones en modo post-competencia. Si lo deseas puedes seguir resolviendo problemas en este modo luego del fin de un contest, aunque todos los puntos de los problemas que resuelvas as\u00ed van directo a tu excedente de puntaje, y por ende ser\u00e1n multiplicados por 0.3 (en otras palabras, rinde m\u00e1s resolver problemas dentro de plazo que fuera de plazo)</p> </li> </ul>"},{"location":"about/how_course_works/#2-asistencia","title":"2) Asistencia","text":"<p>Para fomentar la participaci\u00f3n y asistencia a clases, este curso incluye nota por asistencia, la cual corresponde al 25% de la nota del curso. Para quedar presente eso s\u00ed s\u00f3lo basta con que vengas a un modulo, no es necesario que est\u00e9s presente toda la clase, aunque si pudieras quedarte los 3 m\u00f3dulos ser\u00eda estupendo!</p> <p>En caso de inasistencia, existe la posibilidad de recuperar (parcial o totalmente) la asistencia de ese d\u00eda haciendo m\u00e1s problemas del contest respectivo. Para este efecto, vamos a considerar que una asistencia vale 3 puntos. Si faltas a una clase pero en el contest respectivo tu excedente de puntaje es mayor o igual a 3, se considerar\u00e1 como si hubieras asistido (obviamente, esos 3 puntos no se contabilizar\u00e1n en tu excedente de puntaje total). En cambio, si tu excedente de puntaje es menor a 3, la asistencia se recuperar\u00e1 s\u00f3lo \"parcialmente\". En otras palabras, los que lo deseen pueden hacer el curso entero desde la casa, pero tendr\u00e1n que programar m\u00e1s :)</p> <p>Adem\u00e1s, se perdonar\u00e1n 2 inasistencias. Es decir, puedes faltar a dos clases sin necesidad de recuperar la asistencia y tu nota no ser\u00e1 afectada.</p>"},{"location":"about/how_course_works/#3-bonuses","title":"3) Bonuses","text":"<p>Adem\u00e1s de las competencias semanales, existen varias formas de obtener d\u00e9cimas de bonus, las que se ponderar\u00e1n y sumar\u00e1n directamente a tu nota final:</p>"},{"location":"about/how_course_works/#31-bonus-c","title":"3.1) BONUS C++","text":"<p>Bonus para incentivar el uso de C++ (el lenguaje m\u00e1s popular en progcomp). \u00bfC\u00f3mo obtener este bonus?</p> <ul> <li>Primero que todo, este bonus es v\u00e1lido s\u00f3lo para gente sin (o con demasiada poca) experiencia previa programando en C++. Si ya tienes experiencia en C++ (o en C, que es muy parecido), este bonus no es para ti.</li> <li>Para obtener este bonus, en alg\u00fan momento durante el semestre debes avisarnos que quieres cobrar este bonus. Debes indicarnos los contests y respectivos problemas que has hecho en C++. Nosotros revisaremos tus c\u00f3digos. Para obtener el 100% del bonus, se debe notar un dominio progresivo de C++ en tus c\u00f3digos. Haber logrado resolver al menos un problema complicado en C++ es un plus.</li> <li>Puedes obtener hasta un m\u00e1ximo de 10 d\u00e9cimas con este bonus.</li> <li>Este bonus s\u00f3lo puede ser cobrado una vez en todo el semestre (una posibilidad es esperar hasta el final del semestre y ah\u00ed reci\u00e9n cobrarlo).</li> <li>Si quieres aprender C++, puedes encontrar hartos recursos ac\u00e1.</li> </ul>"},{"location":"about/how_course_works/#32-bonus-rpc-grupal","title":"3.2) BONUS RPC (grupal)","text":"<p>Cada cierto tiempo la Red de Programaci\u00f3n Competitiva (RPC) organiza competencias de entrenamiento. El calendario y registro para estas competencias se encuentran ac\u00e1: http://registro.redprogramacioncompetitiva.com/contests, y los scoreboards de las competencias pasadas se pueden encontrar ac\u00e1: http://redprogramacioncompetitiva.com/Contest. N\u00f3tese que se trata de un bonus grupal, por ende para obtener este bonus deben:</p> <ul> <li>Registrarse en una competencia en grupos de 2 o 3 alumn@s.</li> <li>Participar en la competencia</li> <li>Mandar una foto del grupo con todos sus integrantes juntos frente a un mismo computador (necesitamos evidencia de que se juntaron, y adem\u00e1s la idea es que sea lo m\u00e1s parecido a un simulacro de la ICPC, donde los 3 integrantes comparten un mismo PC, como en este ejemplo). [Nota COVID: en caso de pandemia, se acepta un screenshot de zoom, skype, etc.]</li> <li>Al terminar la competencia, deben mandar el link al scoreboard final de la competencia RPC en que participaron.</li> <li>El bonus se calcular\u00e1 como \\(5 \\cdot \\frac{X}{N}\\) d\u00e9cimas, donde \\(X =\\) problemas resueltos por el grupo, \\(N =\\) problemas resueltos por el equipo que qued\u00f3 en primer lugar. Las \\(5 \\cdot \\frac{X}{N}\\) d\u00e9cimas obtenidas se sumar\u00e1n a las d\u00e9cimas de bonus de cada integrante del equipo.</li> </ul>"},{"location":"about/how_course_works/#33-bonus-contest-individual","title":"3.3) BONUS Contest Individual","text":"<p>Existen muchos sitios online que organizan competencias individuales cada cierto tiempo. Los alumnos tienen la opci\u00f3n de participar en estas competencias y obtener d\u00e9cimas de bonus. Los sitios que m\u00e1s recomendamos son Codeforces, Atcoder y Codechef. Todos tienen calendarios: calendario codeforces, calendario atcoder, calendario codechef. Para obtener este bonus debes:</p> <ul> <li>Registrarte en Codeforces, Atcoder y/o Codechef.</li> <li>Participar en una competencia individual (generalmente duran alrededor de 2 horas).</li> <li>Al final de la competencia avisarnos en qu\u00e9 competencia participaste y mandar el link al ranking donde quedaste.</li> <li>El bonus se calcular\u00e1 como \\(3 \\cdot \\frac{X}{N}\\) d\u00e9cimas, donde \\(X =\\) cantidad de problemas resueltos por ti, \\(N =\\) cantidad de problemas resueltos por la persona que qued\u00f3 en primer lugar. Las \\(3 \\cdot \\frac{X}{N}\\) d\u00e9cimas obtenidas se sumar\u00e1n a tus d\u00e9cimas de bonus.</li> </ul>"},{"location":"about/how_course_works/#34-super-bonus-codeforces","title":"3.4) SUPER BONUS Codeforces","text":"<p>Codeforces tiene un sistema de rating parecido al ELO en Ajedrez. Cualquier alumn@ que participe en al menos 3 contests de Codeforces durante el semestre y luego de ello alcance un rating de 1700 o superior, autom\u00e1ticamente tendr\u00e1 nota final 7.0 en el curso.</p>"},{"location":"about/introduction/","title":"Introducci\u00f3n","text":"<p>Este es un curso pr\u00e1ctico que prepara a los estudiantes para resolver problemas algor\u00edtmicos de programaci\u00f3n competitiva, como los que aparecen en competencias como la ACM ICPC, Google CodeJam, Facebook Hacker Cup y similares a los que preguntan empresas como Amazon y Google en sus entrevistas de trabajo. Los estudiantes ejercitar\u00e1n sus conocimientos de estructuras de datos y algoritmos, su ingenio y sus habilidades de programaci\u00f3n mediante la resoluci\u00f3n semanal de problemas de programaci\u00f3n competitiva. Adem\u00e1s, los alumnos podr\u00e1n optar a un cupo para representar a la Universidad en la competencia regional de la ICPC celebrada en Noviembre de cada a\u00f1o, y eventualmente en la ICPC World Final, celebrada en Abril del a\u00f1o siguiente.</p> <p>Al tratarse de un curso pr\u00e1ctico, la mayor\u00eda de tu tiempo te la pasar\u00e1s programando. No obstante, las habilidades que adquirir\u00e1s ac\u00e1 van m\u00e1s all\u00e1 que simplemente ganar competencias:</p> <ul> <li>Repasar\u00e1s, expandir\u00e1s y profundizar\u00e1s tus conocimientos en estructuras de datos y algoritmos.</li> <li>Te volver\u00e1s un programador o programadora mucho m\u00e1s cuidados@ y precis@. Desarrollar\u00e1s el h\u00e1bito de considerar siempre los l\u00edmites de tiempo y memoria al escribir tus c\u00f3digos, as\u00ed como estar siempre preocupad@ de los casos bordes.</li> <li>Ejercitar\u00e1s tus habilidades de debugging, y m\u00e1s importante a\u00fan, aprender\u00e1s a identificar cu\u00e1ndo hay riesgo de bugs y c\u00f3mo escribir buenos c\u00f3digos que permitan prevenirlos.</li> <li>Ejercitar\u00e1s la habilidad de pensar creativamente antes de programar. Con el tiempo ver\u00e1s c\u00f3mo los problemas te obligar\u00e1n a pensar de forma ingeniosa y creativa para dise\u00f1ar soluciones eficientes y correctas, que cumplan con todas las restricciones.</li> </ul> <p>Todas estas habilidades son sumamente \u00fatiles no solo aqu\u00ed sino tambi\u00e9n en los dem\u00e1s cursos de la malla de Ciencia de Computaci\u00f3n, adem\u00e1s de ser ampliamente valoradas y buscadas por empresas de la industria de software (ej. Google, Facebook, Microsoft) y a la larga muy \u00fatiles en tu carrera profesional.</p>"},{"location":"about/syllabus/","title":"Temario","text":""},{"location":"about/syllabus/#estructuras-de-datos-4-semanas","title":"Estructuras de Datos (4 semanas)","text":"<ul> <li>Estructuras de datos en C++ STL (para llegar y usar)</li> <li>Sparse Tables</li> <li>Segment Tree</li> <li>Segment Tree Lazy</li> <li>Fenwick Tree</li> <li>Fenwick Tree 2D</li> <li>Union Find</li> </ul>"},{"location":"about/syllabus/#algoritmos-de-grafos-3-semanas","title":"Algoritmos de Grafos (3 semanas)","text":"<ul> <li>MST (minimun spanning tree)</li> <li>LCA (lowest common ancestor)</li> <li>Puntos de Articulaci\u00f3n, Aristas de Corte y Componentes Biconexas</li> <li>SCC (strongly connected components)</li> <li>Flujo m\u00e1ximo y aplicaciones</li> </ul>"},{"location":"about/syllabus/#algoritmos-de-strings-2-semanas","title":"Algoritmos de Strings (2 semanas)","text":"<ul> <li>Trie</li> <li>Suffix Array</li> <li>Suffix Automaton (?)</li> <li>Rolling Hashing</li> <li>KMP (Knuth Morris Pratt)</li> </ul>"},{"location":"about/syllabus/#geometria-1-o-2-semanas","title":"Geometr\u00eda (1 o 2 semanas)","text":"<ul> <li>Producto punto y producto cruz</li> <li>C\u00e1lculo de \u00e1reas</li> <li>Convex Hull</li> <li>Sweep Lines</li> </ul>"},{"location":"about/syllabus/#repaso-de-temas-varios-vistos-el-primer-semestre","title":"Repaso de temas varios vistos el primer semestre","text":"<ul> <li>Binary &amp; Ternary Search</li> <li>Backtracking</li> <li>DP (programaci\u00f3n din\u00e1mica)</li> <li>Grafos b\u00e1sico (BFS/DFS/camino m\u00e1s corto)</li> <li>Matem\u00e1tica</li> </ul>"},{"location":"contests/","title":"Contests","text":""},{"location":"contests/#contest-1","title":"Contest 1","text":"<p>Agosto 11, 15 d\u00edas, link a contest</p> <p>T\u00f3picos: Estructuras de Datos de C++ STL</p> <p>Puntos:</p> Problema <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> <code>I</code> <code>J</code> <code>K</code> Puntaje 4 3 3 4 4 3 3 3 4 4 6 <p>Puntaje M\u00ednimo Esperado: 5</p> <p>Hints y c\u00f3digos de ejemplo: link</p>"},{"location":"contests/#contest-2","title":"Contest 2","text":"<p>Agosto 19, 14 d\u00edas, link a contest</p> <p>T\u00f3picos: Estructuras de Datos de C++ STL</p> <p>Puntos:</p> Problema <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> Puntaje 2 4 4 3 4 4 3 6 <p>Puntaje M\u00ednimo Esperado: 5</p> <p>Hints y c\u00f3digos de ejemplo: link</p>"},{"location":"contests/#contest-3","title":"Contest 3","text":"<p>Agosto 26, 14 d\u00edas, link a contest</p> <p>T\u00f3picos: Segment Tree, Fenwick Tree, Sparse Table</p> <p>Puntos:</p> Problema <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> Puntaje 4 3 2 3 3 4 5 7 <p>Puntaje M\u00ednimo Esperado: 5</p> <p>Hints y c\u00f3digos de ejemplo: link</p>"},{"location":"contests/#contest-4","title":"Contest 4","text":"<p>Septiembre 02, 14 d\u00edas, link a contest</p> <p>T\u00f3picos: Lazy Segment Tree, Fenwick Tree 2D, Union Find</p> <p>Puntos:</p> Problema <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> Puntaje 4 4 4 3 3 4 2 8 <p>Puntaje M\u00ednimo Esperado: 5</p> <p>Hints y c\u00f3digos de ejemplo: link</p>"},{"location":"contests/#contest-5","title":"Contest 5","text":"<p>Septiembre 09, 14 d\u00edas, link a contest</p> <p>T\u00f3picos: Grafos: MST &amp; LCA</p> <p>Puntos:</p> Problema <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> Puntaje 3 2 6 4 5 4 4 4 <p>Puntaje M\u00ednimo Esperado: 5</p> <p>Hints y c\u00f3digos de ejemplo: link</p>"},{"location":"contests/#contest-6","title":"Contest 6","text":"<p>Septiembre 23, 14 d\u00edas, link a contest</p> <p>T\u00f3picos: Grafos: SCC, Aristas de Corte y Puntos de Articulaci\u00f3n</p> <p>Puntos:</p> Problema <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> Puntaje 2 3 3 3 4 5 7 5 <p>Puntaje M\u00ednimo Esperado: 5</p> <p>Hints y c\u00f3digos de ejemplo: link</p>"},{"location":"contests/#contest-7","title":"Contest 7","text":"<p>Septiembre 30, 14 d\u00edas, link a contest</p> <p>T\u00f3picos: Grafos: Dinic y Flujo M\u00e1ximo</p> <p>Puntos:</p> Problema <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> Puntaje 4 4 5 4 3 5 5 6 <p>Puntaje M\u00ednimo Esperado: 5</p> <p>Hints y c\u00f3digos de ejemplo: link</p>"},{"location":"contests/#contest-8","title":"Contest 8","text":"<p>Octubre 07, 14 d\u00edas, link a contest</p> <p>T\u00f3picos: Strings: Rolling Hashing, Trie</p> <p>Puntos:</p> Problema <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> Puntaje 4 3 5 3 4 5 4 <p>Puntaje M\u00ednimo Esperado: 5</p> <p>Hints y c\u00f3digos de ejemplo: link</p>"},{"location":"contests/#contest-9","title":"Contest 9","text":"<p>Octubre 14, 14 d\u00edas, link a contest</p> <p>T\u00f3picos: Strings: KMP, suffix array</p> <p>Puntos:</p> Problema <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> Puntaje 2 4 6 4 7 4 3 10 <p>Puntaje M\u00ednimo Esperado: 5</p> <p>Hints y c\u00f3digos de ejemplo: link</p>"},{"location":"contests/#contest-10","title":"Contest 10","text":"<p>Octubre 21, 16 d\u00edas, link a contest</p> <p>T\u00f3picos: Geometr\u00eda: Producto Punto, Producto Cruz</p> <p>Puntos:</p> Problema <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> Puntaje 7 2 3 3 4 4 5 6 <p>Puntaje M\u00ednimo Esperado: 5</p> <p>Hints y c\u00f3digos de ejemplo: link</p>"},{"location":"contests/#contest-11","title":"Contest 11","text":"<p>Octubre 28, 16 d\u00edas, link a contest</p> <p>T\u00f3picos: Geometr\u00eda: Sweep line</p> <p>Puntos:</p> Problema <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> Puntaje 4 5 5 5 6 4 4 4 <p>Puntaje M\u00ednimo Esperado: 5</p> <p>Hints y c\u00f3digos de ejemplo: link</p>"},{"location":"contests/#contest-12","title":"Contest 12","text":"<p>Noviembre 04, 16 d\u00edas, link a contest</p> <p>T\u00f3picos: Geometr\u00eda: Convex Hull, Teorema de Green y m\u00e1s</p> <p>Puntos:</p> Problema <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> Puntaje 3 4 5 4 4 4 4 5 <p>Puntaje M\u00ednimo Esperado: 5</p> <p>Hints y c\u00f3digos de ejemplo: link</p>"},{"location":"contests/#contest-13","title":"Contest 13","text":"<p>Noviembre 11, 16 d\u00edas, link a contest</p> <p>T\u00f3picos: Mate (GCD, N\u00fameros Primos, Aritm\u00e9tica Modular)</p> <p>Puntos:</p> Problema <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> Puntaje 4 4 2 3 5 5 4 5 <p>Puntaje M\u00ednimo Esperado: 5</p> <p>Hints y c\u00f3digos de ejemplo: link</p>"},{"location":"contests/#contest-14","title":"Contest 14","text":"<p>Noviembre 18, 16 d\u00edas, link a contest</p> <p>T\u00f3picos: Mate (GCD extendido, CRT y m\u00e1s)</p> <p>Puntos:</p> Problema <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> <code>I</code> Puntaje 4 5 3 4 4 3 3 4 4 <p>Puntaje M\u00ednimo Esperado: 5</p> <p>Hints y c\u00f3digos de ejemplo: pendiente</p>"},{"location":"contests/#contest-15","title":"Contest 15","text":"<p>Noviembre 25, 16 d\u00edas, link a contest</p> <p>T\u00f3picos: Problemas f\u00e1ciles de implementaci\u00f3n (contest f\u00e1cil, para que suban la nota).</p> <p>Puntos:</p> Problema <code>A</code> <code>B</code> <code>C</code> <code>D</code> <code>E</code> <code>F</code> <code>G</code> <code>H</code> Puntaje 2 3 4 2 2 4 3 3 <p>Puntaje M\u00ednimo Esperado: 5</p> <p>Hints y c\u00f3digos de ejemplo: pendiente</p>"},{"location":"contests/hints/contest1/","title":"Contest 1 - hints y c\u00f3digos de ejemplo","text":""},{"location":"contests/hints/contest1/#a-largest-rectangle-in-a-histogram","title":"A - Largest Rectangle in a Histogram","text":"Hint   El rect\u00e1ngulo m\u00e1ximo necesariamente tiene una altura igual a alguna columna. S\u00f3lo hay N columnas, as\u00ed que puedes ponerte en los N casos, y s\u00f3lo te falta saber el ancho. Dada una columna i-\u00e9sima, piensa en alguna forma de encontrar los extremos L[i] y R[i] del rect\u00e1ngulo maximal que se formar\u00eda si expandimos la columna i-\u00e9sima lo m\u00e1s que se puede hacia ambos lados.  Soluci\u00f3n + c\u00f3digo   Primero calculamos L[i] de izquierda a derecha (para R[i] podemos hacer lo mismo al rev\u00e9s). Para ello mantenemos un stack, en cada instante el stack guarda los distintos m\u00ednimos acumulados de las alturas de las columnas medidos desde la columna i-1 hacia la izquierda, junto con el extremo derecho donde comienza a regir cada m\u00ednimo (para entender mejor esto, dibujar un histograma, pararse en alguna columna de al medio y dibujar la altura del m\u00ednimo acumulado hacia la izquierda, se ve como una funci\u00f3n escalonada). Con ese stack es f\u00e1cil encontrar L[i] (hacemos pop hasta que llegamos a un m\u00ednimo &lt; H[i]) y actualizarlo (pusheamos el par (H[i],i)). Como cada columna es pusheada y popeada s\u00f3lo 1 vez, la complejidad es O(N). C\u00f3digo de ejemplo"},{"location":"contests/hints/contest1/#b-weird-function","title":"B - Weird Function","text":"Hint   La clave del problema es ordenar los datos de una forma que permita acceder eficientemente a la mediana de estos ordenados.  Soluci\u00f3n + c\u00f3digo   Podemos mantener un MaxHeap con la mitad inferior de los datos y un MinHeap con la mitad superior de los datos, tal que podemos acceder a la mediana como el tope del MaxHeap inferior en O(1). Cada vez que agregamos un dato lo agregamos al MaxHeap, si el mayor del MaxHeap es mayor que el menor del MinHeap hacemos un swap de estos datos, y si se desequilibran en tama\u00f1o pasamos el mayor del MaxHeap al MinHeap.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest1/#c-valeriy-and-deque","title":"C - Valeriy and Deque","text":"Hint       Ver si en el alg\u00fan momento las cosas comienzan a repetirse c\u00edclicamente y aprovechar eso  Soluci\u00f3n + c\u00f3digo    Simular hasta que el m\u00e1ximo quede al comienzo. De ah\u00ed en adelante los que est\u00e1n a la derecha del m\u00e1ximo van rotando. Para las queries que van antes del ciclo responde con lo simulado, y para las queries que caen dentro del ciclo calcula modularmente cual va a ser el elemento sacado. C\u00f3digo de ejemplo"},{"location":"contests/hints/contest1/#d-roadwork","title":"D - Roadwork","text":"Hint 1   Para facilitar el an\u00e1lisis, en vez de pensar para cada persona con qu\u00e9 obst\u00e1culo choca, lo podemos ver como para cada obst\u00e1culo, qu\u00e9 personas detiene.   Podemos ver que el obt\u00e1culo en X entre S y T detiene a la persona que parte en D si S - X &lt;= D &lt; T - X.  Hint 2   Si analizamos los obst\u00e1culos y las personas en orden temporal (obst\u00e1culos tomando tiempo entre los que si una persona sale choca con el) y llevamos cuenta de los intervalos activos, podemos responder la distancia que caminar\u00e1 (en caso de parar) si mantenemos la posici\u00f3n de los obst\u00e1culos en una estructura ordenada.  Soluci\u00f3n + c\u00f3digo   Podemos generar un vector de eventos temporales el cual recorreremos en orden, los eventos pueden ser, empieza el efecto de un obst\u00e1culo (S - X como en Hint 1), termina el efecto de un obst\u00e1culo y sale una persona. Al recorrer el vector, basta mantener un multiset ordenado con la posici\u00f3n de los obst\u00e1culos que est\u00e9n activos para poder responder la distancia caminada para cada persona en O(1) cuando salga el evento correspondiente y con updates en O(log N) al empezar o terminar alguno.   La complejidad total de esta soluci\u00f3n es O((N + Q) log(N + Q))   Soluci\u00f3n ejemplo"},{"location":"contests/hints/contest1/#e-memory-management","title":"E - Memory Management","text":"Hint    El problema se puede modelar como una simulaci\u00f3n de eventos en el tiempo, desempatando por id. Los bloques libres tambi\u00e9n se pueden modelar con una estructura que priorice de izquierda a derecha.  Soluci\u00f3n + c\u00f3digo   Podemos definir un struct Event para modelar eventos que pueden ser de 3 tipos: memory allocation, memory access y memory release. Los eventos los podemos simular en orden en una priority queue, sacando el siguiente evento del tope dentro de un while. Los eventos de alloc y access son los dados por el input. Los eventos de release los agregamos a medida que vamos simulando y un alloc o access es exitoso. Notar que los release pueden quedar obsoletos (por ej. un access puede extender el periodo de ocupaci\u00f3n de un bloque, entonces eventos de release con un timestamp menor ya no son v\u00e1lidos), por lo tanto hay que registrar el \u00faltimo release time por bloque y comparar contra eso para descartar los release obsoletos. A su vez, los bloques de memoria libres se pueden modelar con una priority_queue tambi\u00e9n (para ir sacando siempre el de m\u00e1s a la izquierda). C\u00f3digo de ejemplo"},{"location":"contests/hints/contest1/#f-criss-cross-cables","title":"F - Criss-cross Cables","text":"Hint   Hay N*(N-1)/2 pares de ubicaciones posibles, que si los ordenamos por largo de menor a mayor codiciosamente nos convendr\u00edan los M primeros \u00bfverdad? Piensa en una forma de encontrar los M primeros sin tener que generar los N*(N-1)/2 pares expl\u00edcitamente.  Soluci\u00f3n + c\u00f3digo   Ordenamos los cables por largo de menor a mayor. Adem\u00e1s, usamos un minheap (priority_queue) y primero lo llenamos con intervalos correspondientes a pares consecutivos (i, i+1). Luego de forma sincronizada iteramos sobre los cables y vamos sacando intervalos del minheap, si el alg\u00fan punto el cable no se la puede o nos quedamos cortos de intervalos, no se puede. Si no, cada vez que sacamos un intervalo, metemos al minheap un nuevo intervalo alargado un \u00edndice m\u00e1s a la derecha (o sea, si sacamos el intervalo (i,j), metemos el intervalo (i,j+1)). La complejidad es O(M log M + M log N). C\u00f3digo de ejemplo"},{"location":"contests/hints/contest1/#g-equeue","title":"G - equeue","text":"Hint    Notar que los l\u00edmites son chiquitos, as\u00ed que podemos ponernos en todos los casos de sacar por la izquierda y la derecha.  Soluci\u00f3n + c\u00f3digo    Nos ponemos en todos los casos: hacemos dos fors, uno sobre la cantidad de valores que sacamos por la izquierda (L) y otro for sobre la cantidad de valores que sacamos por la derecha (R). Eso define nuestra mano. Luego, con las K-L-R jugadas que nos quedan, codiciosamente las gastamos en botar valores negativos, del m\u00e1s negativo al menos negativo. Eso se puede hacer con una priority_queue. La respuesta va a ser el mejor caso encontrado. C\u00f3digo de ejemplo"},{"location":"contests/hints/contest1/#h-two-teams","title":"H - Two Teams","text":"Hint 1   Podemos ordenar los estudiantes del con mayor habilidad al con menos habilidad podemos agregarlos a un MaxHeap, que agrega elementos en O(log N), consulta por el mayor en O(1) y quita el mayor en O(log N).  Hint 2   Podemos visitar uno por uno los estudiantes y marcar el equipo correspondiente a los alumnos k a la derecha y a la izquierda no marcados, el problema es que si visitamos muchas veces estudiantes no marcados el algoritmo no cae en el l\u00edmite de tiempo. Debemos encontrar una forma de no visitar m\u00e1s que una vez cada estudiante. Una estructura perfecta para esto es una lista ligada tal que podamos eliminar segmentos de un arreglo en O(1).  Soluci\u00f3n + c\u00f3digo   Recorremos en orden los estudiantes, para cada uno, si no ha sido marcado marcamos k a la derecha y a la izquierda de la lista y eliminamos el segmento.   Podemos simular la lista ligada usando vectores R, L, tal que R[i] indica qu\u00e9 indice est\u00e1 actualmente a la derecha de i y L[i] a la izquierda de i. al eliminar un segmento s\u00f3lo debemos unir el de la izquierda del primer eliminado con el de la derecha del \u00faltimo, as\u00ed en consultas siguientes no se pasar\u00e1 por lo eliminado.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest1/#i-cat-party","title":"I - Cat Party","text":"Hint   Si pudieramos mantener conteo de las frecuencias de cada color hasta el \u00edndice i, este ser\u00e1 v\u00e1lido en 3 casos, si todos son del mismo color, si hay un color con frecuencia 1 y todo el resto son iguales o si todos son iguales excepto un color con frecuencia 1 m\u00e1s que el resto. En todos estos casos eliminar 1 funcionar\u00eda. Piensen en una forma de mantener frecuencias y poder chequear esos casos eficientemente.  Soluci\u00f3n + c\u00f3digo   Si iteramos por \u00edndice y mantenemos un multiset ordenado con las frecuencias de cada color que hemos visto podemos chequear todos los casos eficientemente usando iteradores. El primer caso se chequear\u00eda viendo si el tama\u00f1o del multiset es 1, el segundo caso si el elemento m\u00e1s peque\u00f1o del multiset es 1 y el siguiente es igual al \u00faltimo, y el \u00faltimo caso si el \u00faltimo elemento del m\u00faltiset es igual al primero - 1 y el primero es igual al pen\u00faltimo.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest1/#j-who-is-the-boss","title":"J - Who is The Boss","text":"Hint   Podemos ir acumulando la cantidad de subordinados de cada empleado, si todos parten en 0 al ver cual es el jefe los subordinados se le suman.   Si ordenamos los empleados por salario, todos aquellos empleados ya visitados que no tengan jefe y de altura menor o igual a la del empleado actual ser\u00e1n subordinados y la cantidad de subordinados se acumula. Piensen en una forma eficiente de mantener ordenados los empleados ya visitados sin jefe para hacer eso.  Soluci\u00f3n + c\u00f3digo   Si visitamos a los empleados seg\u00fan salario como en el Hint 1, basta mantener un set ordenado o un MinHeap de los empleados ya visitados sin jefe ordenados or altura, luego para cada empleado, agregamos como subordinados a todos aquellos miembros del MinHeap con altura menor o igual a la actual, acumulamos el conteo de subordinados y eliminamos del MinHeap.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest1/#k-daunting-device","title":"K - Daunting Device","text":"Hint   Pensar el problema como intervalos de colores. Inicialmente partimos con un intervalo [0, L-1] pintado todo de color 1, y en cada iteraci\u00f3n estamos haciendo una actualizaci\u00f3n que nos deja una nueva secuencia de intervalos.  Soluci\u00f3n + c\u00f3digo   Definimos un struct Interval con 3 variables: \u00edndice donde comienza, \u00edndice donde termina y color. Adem\u00e1s mantenemos un std::set de C++ (un set ordenado) con los intervalos de colores actuales (inicialmente {0, L-1, 1}). Para saber cu\u00e1ntas veces aparece un color, mantenemos un arreglo o vector \"freq\" (o como quieran llamarle) con las frecuencias de cada color. Luego nos queda implementar el c\u00f3digo que ejecuta los N updates. Calculamos M1 y M2 seg\u00fan enunciado. Luego debemos encontrar la secuencia de intervalos en nuestro set que son afectados por el update. Esto se puede hacer usando s.lower_bound() y manipulando iteradores (ver c\u00f3digo de ejemplo si te complicas mucho con esto, aunque intenta primero revisar el material del curso sobre sets de C++ y sobre iteradores). Luego podemos borrar todos intervalos con s.erase(), insertar el nuevo intervalo y posiblemente insertar 2 intervalos nuevos en los bordes (si es que nuestro update borra parcialmente algunos de los 2 intervalos vecinos (izquierdo y/o derecho)). Luego de los N updates, la respuesta es el m\u00e1ximo en un nuestro arreglo/vector \"freq\".  C\u00f3digo de ejemplo"},{"location":"contests/hints/contest10/","title":"Contest 10 - Hints y c\u00f3digos de ejemplo","text":""},{"location":"contests/hints/contest10/#a-treasure-spotting","title":"A - Treasure Spotting","text":"Hint 1   Se debe chequear para cada pirata la visibilidad del tesoro, para eso debemos chequear tres cosas, que el tesoro est\u00e9 en el semidisco visible para el pirata, que para toda muralla no lo tape y que para todo otro pirata no lo tape. Si podemos hacer cada chequeo en tiempo constante el algoritmo pasar\u00e1 en tiempo.  Hint 2   Para chequear que el tesoro se encuentra en el semidisco de visi\u00f3n basta ver que este a una distancia menor o igual a la del radio entregado por input (se calcula como la distancia entre los puntos entregados para el pirata en R2) y que adem\u00e1s el producto punto entre el vector de visi\u00f3n entregado AB y el vector al tesoro AT sea mayor o igual a 0.  Hint 3   Para chequear que cada muralla no tape basta con chequear si los segmentos AT y CD intersectan, donde AT es del pirata al tesoro y CD es la muralla. Para chequear intersecci\u00f3n de segmentos se puede ver que para cada segmento, los puntos del otro segmento est\u00e9n a lados distintos de la recta generada por el segmento analizado, si esto pasa para ambos hay intersecci\u00f3n. Tambi\u00e9n habr\u00e1 intersecci\u00f3n si alguno de los puntos de un segmento est\u00e1 en el otro segmento.  Soluci\u00f3n + c\u00f3digo   La soluci\u00f3n consiste en usar los hints e implementarlo correctamente teniendo en cuenta la precisi\u00f3n, para evitar problemas evitar el uso de doubles a menos que se considere peque\u00f1as variaciones.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest10/#b-inside-or-outside","title":"B - Inside or outside?","text":"Hint   Para cada punto, para que est\u00e9 dentro del pol\u00edgono basta que este en el mismo lado en todos los segmentos del pol\u00edgono, es decir, que siempre est\u00e9 a la izquierda de la linea generada por cada segmento o siempre a la derecha. Basta chequear con producto cruz.  Soluci\u00f3n + c\u00f3digo   Basta usar el hint para obtener la soluci\u00f3n.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest10/#c-left-right-or-center","title":"C - Left, right or center?","text":"Hint   Pueden detectar a que lado de una recta generada por un segmento se encuentra un punto haciendo uso del producto cruz, si la recta esta dada por el segmento AB y el punto est\u00e1 en P, el producto AB x AP ser\u00e1 positivo si el punto est\u00e1 a la derecha o negativo en caso contrario.  Soluci\u00f3n + c\u00f3digo   La respuesta consiste en usar el hint directamente.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest10/#d-counting-triangles","title":"D - Counting Triangles","text":"Hint   Una opci\u00f3n es ver para cada tr\u00edo se segmentos, si todos se intersectan de a dos entonces forman un tri\u00e1ngulo. Acumulando las veces que se formen tri\u00e1ngulos se otendr\u00e1 la respuesta.  Soluci\u00f3n + c\u00f3digo   La soluci\u00f3n consiste en usar el hint. Para saber si segmentos intersectan pueden usar el hint 3 de la pregunta A.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest11/","title":"contest 11 - hints y c\u00f3digos de ejemplo","text":""},{"location":"contests/hints/contest11/#a-the-skyline-problem","title":"A - The Skyline Problem","text":"Hint 1   Cuando se hace un problema con el t\u00f3pico de Sweep Line se tiene que encontrar cu\u00e1l es el segmento y en qu\u00e9 direcci\u00f3n barrer\u00e1 el plano, cu\u00e1ndo es que topa con un evento y qu\u00e9 sucede en cada evento. \u00bfCu\u00e1les son los eventos en este problema? \u00bfQu\u00e9 implica que comience un nuevo edificio o termine otro? y, \u00bfEn qu\u00e9 importa si es m\u00e1s o menos algo que los dem\u00e1s?  Hint 2   Los eventos son cuando comienza y cuando termina un edificio. Lo que nos interesa es para cada evento, saber si cambi\u00f3 la altura m\u00e1xima (que es lo que nos interesa imprimir) y si no queda otro evento en la misma posici\u00f3n que pueda cambiar la altura m\u00e1xima. Piense en qu\u00e9 estructura(s) pueden sernos de ayuda para modelar el problema.  Soluci\u00f3n + c\u00f3digo   Guardamos los eventos y los ordenamos seg\u00fan su posici\u00f3n de menor a mayor. Luego procesamos en un bucle todos los eventos. En cada iteraci\u00f3n procesamos todos los de la misma posici\u00f3n y vemos si al final de este batch cambi\u00f3 o no la altura m\u00e1xima.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest11/#b-fence-the-vegetables-fail","title":"B - Fence the vegetables fail","text":"Hint 1   Podemos hacer un sweep line con una l\u00ednea imaginaria vertical, que barre el plano de izquierda a derecha, generando dos tipos de evento: evento planta y evento segmento vertical. Notar que los segmentos horizontales se pueden ignorar. Durante el sweep line, nos interesa mantener un registro de qu\u00e9 intervalos del eje Y est\u00e1n dentro de la cerca y qu\u00e9 intervalos est\u00e1n fuera. Cuando procesemos un evento planta, queremos saber si dicha planta est\u00e1 dentro o fuera de la cerca, aprovechando la informaci\u00f3n antes mencionada. \u00bfC\u00f3mo podemos hacer esto?  Hint 2   Podemos usar estructura de datos que nos permita hacer updates por rango de manera eficiente, para indicar que un intervalo del eje Y est\u00e1 dentro o fuera de la cerca. Por ejemplo, se puede usar un segmentree lazy para hacer updates por rango. Otra opci\u00f3n es usar la t\u00e9cnica de \"difference array\" (sumar 1 al principio y -1 despu\u00e9s del final) pero de manera din\u00e1mica, lo cual se puede hacer con un segmentree normal o con un fenwick tree. El \u00fanico inconveniente es que los rangos num\u00e9ricos de input pueden ser muy grandes (hasta 10^9) ...  Hint 3   Para no tener problemas con el rango en que se mueven los valores en el eye Y, podemos hacer \"domain compression\", es decir, mapear los valores originales a valores en un rango compacto pero manteniendo el orden relativo.  Soluci\u00f3n + c\u00f3digo   B\u00e1sicamente aplicamos los hints y el problema sale. Intenten programarlo sin ver c\u00f3digos, pero si necesitan ver un c\u00f3digo de ejemplo, ac\u00e1 les dejamos uno:   C\u00f3digo de ejemplo. Por favor no hacer copy-paste, deben programar su propia soluci\u00f3n."},{"location":"contests/hints/contest11/#c-dazzling-stars","title":"C - Dazzling Stars","text":"Hint 1   Se puede reinterpretar como ver si existe un vector (o direcci\u00f3n con sentido) donde al proyectar las estrellas nunca aparezca una estrella de mayor brillo antes que una de menor brillo. Siempre existir\u00e1 esta direcci\u00f3n si los vectores que van de estrellas de menor brillo a mayor brillo no son incompatibles.  Hint 2   Si ordenamos los vectores que van de menor a mayor brillo por \u00e1ngulo, ser\u00e1n compatibles si existe un rango de 180 que los contiene a todos.  Soluci\u00f3n + c\u00f3digo   Basta hacer un sweepline radial con eventos de inicio y final de rango para cada vector. Si tenemos un vector v, agregaremos sus rotaciones en +- 90 grados al sweepline como inicio y fin de rango. Si al recorrer los eventos en orden en alg\u00fan momento todos los rangos est\u00e1n activos la respuesta ser\u00e1 Y.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest11/#e-balloon","title":"E - Balloon","text":"Hint 1   Cada segmento si es inclinado libera globos o hacia otro segmento o hacia el vac\u00edo, esto forma un DAG (directed acyclic graph) de los segmentos sobre el cual podemos aplicar programaci\u00f3n din\u00e1mica para encontrar la soluci\u00f3n al problema. Piensen en c\u00f3mo armar el dag usando un sweepline sobre eventos ordenados por eje x con eventos inicio de segmento, fin de segmento y globo.  Hint 2   Si usamos un sweepline como descrito y mantenemos un set ordenado con los segmentos activos podremos armar el DAG. Para mantener los segmentos ordenados basta usar un comparador de pares de segmentos y usar un set. Dados dos segmentos AB y CD si A.x &gt; C.x entonces AB estar\u00e1 bajo CD si CA x XD &lt; 0.  Hint 3   Podemos armar el dag uniendo cada al segmento que va justo m\u00e1s arriba en el set, esto se define al momento de agregar el segmento si est\u00e1 inclinado hacia la izquierda o al momento de eliminarlo si est\u00e1 inclinado hacia la derecha (Pueden usar upper_bound en c++ para buscar el siguiente segmento). Tambi\u00e9n debemos recordar el menor segmento del set en cada evento globo, pues ser\u00e1 el primero con que choca el globo (la respuesta de este globo ser\u00e1 evaluar el dp en el segmento con que choc\u00f3 primero).  Soluci\u00f3n + c\u00f3digo   Dado el DAG descrito en los hints basta armar un algoritmo de programaci\u00f3n din\u00e1mica que resuelve el problema. Cada segmento busca la respuesta en el segmento al que apunta, en caso de apuntar a un segmento no inclinado se queda en esa posici\u00f3n y en caso contrario se sigue preguntando.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest11/#g-garden-fence","title":"G - Garden Fence","text":"Hint 1   Notemos que a menos que el \u00f3ptimo sea dejar todos los \u00e1rboles a un lado, la soluci\u00f3n siempre ser\u00e1 una recta que separa dos \u00e1rboles de cada tipo. De hecho se puede mostrar que el \u00f3ptimo siempre puede ser alcnzado con una rotaci\u00f3n infinitesimal de alguna recta que una dos \u00e1rboles de cada tipo. Piensen en una forma de recorrer todas las rectas uniendo \u00e1rboles de tipos distintos considerando el costo de elegirla (en una rotaci\u00f3n infinitesimal).  Hint 2   Podemos considerar todas estas en tiempo rectas realizando P sweeplines radiales desde cada \u00e1rbole de tipo P. Usando dos punteros sobre el orden de un sweepline radial de un \u00e1rbol de tipo P es posible acumular y actualizar el costo en tiempo amortizado O(n). Basta acumular cada vez que se avanze el puntero de un rango de 180 el segundo puntero hasta el final del rango. Luego de hacer todos los sweepline, la instancia de menor costo ser\u00e1 la respuesta.  Soluci\u00f3n + c\u00f3digo   Basta implementar los hints. Tener cuidado con puntos colineales, en caso de empate en el sweepline radial siempre conviene usar primero el punto a menor distancia y saltarse el resto para el sweepline (igual deben ser acumulados para el costo).   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest11/#h-hide-and-seek","title":"H - Hide and seek","text":"Hint 1   Piensen en como hacer un sweepline radial desde cada seeking kid donde hayan eventos de comienzo de pared, fin de pared y hiding kid. En el sweepline deben mantener ordenadas las paredes activas en orden de distancia al seeking kid.  Hint 2   Ordenar los eventos de cada sweepline se hace de forma est\u00e1ndar, la dificultad de este problema radica en el orden de los segmentos activos durante el sweepline. Un posible comparador para usar un set para el orden puede ser, dados dos segmentos activos AB y CD, si A empieza despu\u00e9s que C entonces A ser\u00e1 menor si CA x CD &gt; 0 (producto cruz).  Soluci\u00f3n + c\u00f3digo   Dado el sweepline explicado en los hints siempre que un evento hiding kid tenga posici\u00f3n menor a todos los segmentos activos (basta comparar con el m\u00e1s cercano), entonces ser\u00e1 visible desde el seeking kid analizado.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest2/","title":"Contest 2 - hints y c\u00f3digos de ejemplo","text":""},{"location":"contests/hints/contest2/#a-four-segments","title":"A - Four Segments","text":"Hint   Consideren todas las caracter\u00edsticas necesarias de los segmentos de un rect\u00e1ngulo.  Soluci\u00f3n + c\u00f3digo   Hay muchas formas de resolver este problema, una es revisar que se cumplan las siguientes caracter\u00edsticas: 2 segmentos verticales y 2 horizontales, cantidad de puntos totales igual a 4, todos los segmentos son distintos.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest2/#b-nested-dolls","title":"B - Nested Dolls","text":"Hint   Piensen en ordenar las mu\u00f1ecas de forma decreciente por ancho y desempatando de forma creciente por altura. Iterando en este orden piensen en una forma de mantener las mu\u00f1ecas que ya vieron para obtener r\u00e1pidamente la mu\u00f1eca a la que m\u00e1s conviene juntar.  Soluci\u00f3n + c\u00f3digo   Si ordenamos las mu\u00f1ecas segun el hint, podemos mantener las mu\u00f1ecas que ya vimos en un multiset de alturas. Luego en cada momento la mu\u00f1eca con la que m\u00e1s nos conviene unirnos es la con menor altura mayor a la nuestra. Esto se puede encontrar r\u00e1pidamente con un lower_bound(h + 1) en el multiset (investigar multisets en c++). Luego se updatea la mu\u00f1eca en el multiset a la nueva altura interior.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest2/#c-greg-and-array","title":"C - Greg and Array","text":"Hint   Podemos registrar la cantidad de veces que se termina haciendo cada update usando un arreglo de diferencias, la idea es la siguiente, usamos un arreglo U que empieza con 0's y si queremos hacer los updates entre x e y hacemos U[x] += 1, U[y + 1] += 1, luego despues de todas las queries podemos recorrer el arreglo U y la suma de los valores nos entrega la cantidad de veces que se hace cada update.  Soluci\u00f3n + c\u00f3digo   Podemos usar la idea del hint 2 veces, una vez para cuantas veces se hace cada update y otra para saber cuanto se le suma a los A[i], en el caso de la segunda se puede tener un arreglo C donde para cada update hacemos C[L[i]] += d[i] *s, C[R[i] + 1] -= d[i]* s, donde L[i], R[i], d[i] son los l\u00edmites del update i, y s es la variable acumulada del arreglo U. Finalmente la respuesta final se obptiene recorriendo C. La complejidad final de esta soluci\u00f3n termina siendo lineal en N y M.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest2/#d-they-are-everywhere","title":"D - They Are Everywhere","text":"Hint   Piensen en c\u00f3mo calcular r\u00e1pidamente cual es el menor \u00edndice j necesario a visitar asumiendo que empiezo a visitar desde i. Esto se har\u00e1 para cada indice inicial.  Soluci\u00f3n + c\u00f3digo   Podemos usar arreglos acumulados de aparici\u00f3n de cada letra, como son letras min\u00fasculas y may\u00fasculas necesitaremos a lo m\u00e1s 54 arreglos. Luego para cada \u00edndice de inicio i, podemos encontrar el menor \u00edndice necesario j a partir de una b\u00fasqueda binaria, s\u00f3lo se necesita chequear que cada letra ocurra al menos una vez en el rango. La complejidad final es en el peor caso O(54 *N* log N), lo que pasa en tiempo.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest2/#e-petya-and-exam","title":"E - Petya and Exam","text":"Hint   Los eventos interesantes son los momentos en que las preguntas se convierten en obligatorias. Dise\u00f1a un algoritmo que se ponga en todos esos momentos interesantes.  Soluci\u00f3n + c\u00f3digo   Ordenamos las preguntas por su tiempo en que se vuelven obligatorias. Iteramos sobre las preguntas y mantenemos contadores sobre la cantidad de preguntas obligatorias easy y hard que hay que hacer. Sea t el instante en que un grupo de preguntas se vuelven obligatorias. Un momento interesante es t-1 (uno antes que se vuelvan obligatorias), en dicho instante se maximiza el tiempo disponible para resolver las preguntas obligatorias que vienen antes. Si en t-1 alcanzamos a hacer todas las obligatorias, el tiempo sobrante lo gastamos codiciosamente en las preguntas f\u00e1ciles y el resto en las dif\u00edciles que sobran. C\u00f3digo de ejemplo"},{"location":"contests/hints/contest2/#f-the-queue","title":"F - The Queue","text":"Hint 1   Por simplicidad, notar que podemos ignorar toda la gente que llega un tiempo &gt;= tf.  Hint 2   Si hubiese alg\u00fan instante en que pudiesemos llegar y esperar 0, significa que hay una ventana de tiempo entre ts y tf de ancho &gt;= 1 durante la cual la recepcionista est\u00e1 desocupada. Esa ventana tiene cota por la derecha ya sea el instante de llegada de alguien, o bien tf. Podemos cubrir todos esos casos considerando cada instante que llega alguien menos 1, o bien el instante en que se va la \u00faltima persona (ignorando los que llegan &gt;= tf).  Hint 3   Si no fuese posible esperar 0, en cualquier instante que lleguemos siempre quedaremos ubicados atr\u00e1s de alguien en la cola. Podemos ponernos en todos esos casos suponiendo que llegamos en cada instante que llega alguien menos 1 (el menos 1 es para minimizar la espera).  Soluci\u00f3n + c\u00f3digo   Seg\u00fan lo explicado en los hints, b\u00e1sicamente los \u00fanicos instantes interesantes son los tiempos de llegadas menos 1 de cada persona que llega en un t &lt;= tf, o bien el instante en que se desocupa la \u00faltima persona. Hacemos una simulaci\u00f3n de la cola con una queue y la secuencia de instantes de llegada de la gente. Antes de procesar el instante t, sacamos de la cola todos los que se van antes de t (hasta t-1). Ah\u00ed vemos qu\u00e9 pasar\u00eda si llegamos justo en t-1 y actualizamos la respuesta. Lo mismo para el instante en que se va la \u00faltima persona. Un caso borde es que nadie llegue &lt;= tf. En ese caso es obvio que la espera es 0 (basta llegar en ts y estamos). C\u00f3digo de ejemplo"},{"location":"contests/hints/contest2/#g-removing-leaves","title":"G - Removing Leaves","text":"Hint   Piensen en una forma de llevar cuenta de cuantas hojas salen de cada nodo. Luego procesando los nodos en el orden de m\u00e1s hojas saliendo a menos podemos resolver el problema. Ojo con mantener updateadas la cantidad de hojas despues de cada operaci\u00f3n.  Soluci\u00f3n + c\u00f3digo   Una forma de usar el hint es manteniendo un vector o lista L con la cantidad de hojas saliendo de cada nodo (L[u] para el nodo u). Adem\u00e1s ir iterando los nodos del con m\u00e1s hojas al que menos usando una priority_queue, luego para cada nodo que revisemos sumamos a los movimientos L[u] / K. Ojo que luego debemos \"quitar\" estas aristas del grafo y si nos convertimos en hoja sumar 1 a la cantidad de hojas de mi padre y agregarlo a la priority_queue.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest2/#h-jumping-grasshoper","title":"H - Jumping Grasshoper","text":"Soluci\u00f3n + c\u00f3digo C\u00f3digo de ejemplo"},{"location":"contests/hints/contest3/","title":"Contest 3 - hints y c\u00f3digos de ejemplo","text":""},{"location":"contests/hints/contest3/#a-ball","title":"A - Ball","text":"Hint 1   Piensen un una forma de ordenar los datos tal que usando alguna estructura para cada persona podamos saber r\u00e1pidamente si existe alguien que tenga todas las caracter\u00edsticas mayores.  Hint 2   Una posible idea es ordenar a las personas de forma decreciente en una de las caracter\u00edsticas (por ejemplo B) e ir manteniendo en una estructura ordenadas seg\u00fan una segunda caracter\u00edsticas (por ejemplo I) las terceras caracter\u00edsticas (por ejemplo R). Piensen c\u00f3mo mantener esto y en qu\u00e9 estructura ayudar\u00eda a saber si hay alguien dominante r\u00e1pidamente.  Soluci\u00f3n + c\u00f3digo   Siguiendo la idea del hint 2, recorriendo de forma decreciente en una de las caracter\u00edsticas podemos mantener un Segment Tree donde el \u00edndice indica el orden en la 2a caracter\u00edstica y los valores corresponden a la 3a caracter\u00edstica. De esta forma con un query de m\u00e1ximo al segmento (i, end) donde i corresponda a uno m\u00e1s que el valor de la persona que se revisa actualmente, si el mayor valor es mayor que el valor de la 3a caracter\u00edstica actualmente entonces debe haber una persona con mayores valores en cada caracter\u00edstica.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest3/#b-update-the-array","title":"B - Update the array","text":"Hint   Podemos construir un arreglo D de que guarde las diferencias que generan los updates, en otras palabras, si se hace un update l, r, v, realizamos D[l] += v, D[r + 1] -= v. Luego pensar en una forma de rescatar el valor en un \u00edndice de forma r\u00e1pida, luego de los updates y usando el arreglo D.  Soluci\u00f3n + c\u00f3digo   Una forma de resolver este problema de forma online, podemos hacer uso del arreglo de diferencias descrito en el hint y generar un segment tree de el que calcule la suma en un rango. Luego se recupera el valor en un \u00edndice realizando queries de la forma (0, i) a la estructura.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest3/#c-range-minimum-query","title":"C - Range Minimum Query","text":"Hint   Problema de uso directo de alguna de las estructuras vistas en clases  Soluci\u00f3n + c\u00f3digo   Puede ser resuelto con uso directo de Segment Tree o Sparse Tables.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest3/#d-gravel","title":"D - Gravel","text":"Hint 1   Este problema es similar al B - update the array, tenemos updates sobre rangos y consultas puntuales. La diferencia es que ac\u00e1 los updates y consultas pueden estar intercalados.  Hint 2   Al igual que en el problema B - update the array, podemos usar el concepto de difference array, sin embargo, como ac\u00e1 tenemos updates y consultas intercalados, recalcular un difference array a cada rato dar\u00eda TLE. \u00bfSe te ocurre alguna forma de implementar el mismo concepto de difference array pero con una estructura que permita hacer updates y consultas de forma eficiente?  Soluci\u00f3n + c\u00f3digo   Usamos un fenwick tree (a.k.a. bit) para simular un difference array din\u00e1mico. Cuando nos piden hacer un update por rango, hacemos bit.add(l,k) y bit.add(r+1,-k), y cuando nos hacen una consulta puntual consultamos con bit.psq(p). La complejidad es O(M log N). C\u00f3digo de ejemplo"},{"location":"contests/hints/contest3/#e-xenia-and-bit-operations","title":"E - Xenia and Bit Operations","text":"Hint   Pinesen en c\u00f3mo construir un nodo para poder resolver el problema con un Segment Tree  Soluci\u00f3n + c\u00f3digo   Si en cada nodo guardamos el valor y la profundidad inversa (empezando desde 0 en las hojas), podemos realizar distintas operaciones en la uni\u00f3n de dos nodos dependiendo de la profundidad en la que se produzca la uni\u00f3n, es decir, si la profundidad es par unimos con or y si es impar unimos con xor. Ambas operaciones son compatibles con un Segment Tree y la complejidad final es O(m log(2^n)). Ojo que para que de accepted tal vez sea necesario el uso de fast input en c++.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest3/#f-d-query","title":"F - D-query","text":"Hint   Piensa en una forma de ordenar las queries, de tal manera que al ir iterando sobre ellas puedas ir actualizando una estructura de datos que te permita contar cu\u00e1ntos n\u00fameros est\u00e1n activos (teniendo cuidado de nunca activar n\u00fameros duplicados simult\u00e1neamente).  Soluci\u00f3n + c\u00f3digo   Lo que hacemos es ordenar las queries (L,R) de forma creciente en R. Adem\u00e1s, creamos un fenwick tree de tama\u00f1o N en el cual vamos trackeando con 0s y 1s los n\u00fameros del arreglo actualmente activos (inicialmente partimos con puros 0s, i.e. ning\u00fan n\u00famero activo). Luego vamos iterando sobre las queries (crecientes en R) y para cada query hacemos avanzar un puntero r hasta alcanzar el R actual, y en cada paso activamos el n\u00famero r-\u00e9simo (sumamos 1 en la posici\u00f3n r-\u00e9sima del fenwick tree, indicando que el n\u00famero r-\u00e9simo est\u00e1 activo), PERO si el n\u00famero r-\u00e9simo ya estaba activo en una posici\u00f3n anterior, lo desactivamos (sumamos -1 en su posici\u00f3n anterior). De esta manera si un n\u00famero est\u00e1 duplicado, siempre mantenemos activa la posici\u00f3n m\u00e1s a la derecha en la que aparece. Con eso logramos que se cumpla la invariante de que de todos los distintos n\u00fameros dentro del intervalo [1,R] est\u00e9n activados en sus respectivas posiciones m\u00e1s a la derecha (dentro de [1,R]), y todo el resto est\u00e1 desactivado. Luego, para saber cu\u00e1ntos n\u00fameros distintos hay consultamos al fenwick tree la suma acumulada de 1s en el intervalo [L,R]. C\u00f3digo de ejemplo Soluci\u00f3n Alternativa + c\u00f3digo   El problema se puede hacer trivialmente tambi\u00e9n aplicando el algoritmo de MO. C\u00f3digo de ejemplo"},{"location":"contests/hints/contest3/#g-vladik-and-entertaining-flags","title":"G - Vladik and Entertaining Flags","text":"Hint 1   Piensa en una forma de responder la query(L,R) descomponiendo el rango [L,R] en sub-rangos y combinando respuestas precomputadas para dichos sub-rangos.  Hint 2   Sup\u00f3n que tienes la respuesta precomputada para el rango [L,M] y para el rango [M+1, R]. \u00bfC\u00f3mo obtener la respuesta para el rango [L, R]? Notar que las componentes de ambos rangos se fusionan si es que en el punto de contacto entre las columnas M y M+1 hay valores adyacentes iguales. Cualquier componente que no toque la interfaz no se puede fusionar.  Soluci\u00f3n + c\u00f3digo   B\u00e1sicamente usamos ya sea un Sparse Table o un Segment Tree, los rangos los modelamos con un Struct/Class que guarde los \u00edndices L y R del rango, un par de arreglos int left[10] e int right[10] que guarden los ids de las componentes a las que pertenecen los valores de las columnas L y R respectivamente, y un contador de la cantidad de componentes del rango. Para fusionar los rangos A = [L, M] y B = [M+1, R], podemos iterar sincronizadamente sobre las columnas M y M+1 y detectar cuando los valores matrix[M][i] == matrix[M+1][i], en cuyo caso las componentes A.right[i] y B.left[i] deben fusionarse (podemos iterar sobre las 4 columnas A.left, A.right, B.left y B.right y actualizar los ids). Usando Sparse Table la complejidad es O(N^2*M*log(M)) por construir el sparse table y O(Q*N^2*log(M)) por responder las queries. C\u00f3digo de ejemplo"},{"location":"contests/hints/contest3/#h-cut-inequality-down","title":"H - Cut Inequality Down","text":"Hint 1   Si estamos parados en el mes B con un ingreso inicial de X (L &lt;= X &lt;= U), si dibujamos la curva de nuestro ingreso acumulado mensual mes a mes (X + la sumatoria de los A hasta el mes actual) ignorando las cotas U y L, notaremos que la curva a veces choca con la cota L y a veces con la cota U. Notar que el instante que nos interesa encontrar es el primer choque (el mes del choque y con cu\u00e1l de las 2 cotas chocamos). De ah\u00ed en adelante el proceso se puede pensar como ir saltando de choque en choque, hasta llegar al \u00faltimo choque que no se pase del mes E. Desde ese punto hasta E no hay choques, as\u00ed que ah\u00ed es f\u00e1cil calcular el dinero total en el mes E.  Hint 2   Si estamos en el mes B con un ingreso inicial de X, \u00bfc\u00f3mo podemos encontrar el mes y la cota del siguiente choque? Una forma de verlo es pensar en una estrategia para encontrar el primer choque con cada cota (U y L) suponiendo que la otra cota no existe, y el primero de los dos que ocurra es el siguiente choque.  Hint 3   Si para cada par (i, cota) tenemos precomputado el siguiente choque (i', cota'), la query (X, B, E) se podr\u00eda resolver de la siguiente manera: primero encontrar el primer choque, si ocurre pasado de E, entonces no hay choques entre B y E y el c\u00e1lculo es trivial, si hay choque, entonces nos paramos en el choque (i, cota) y seguimos los punteros al siguiente choque (i', cota') y as\u00ed sucesivamente hasta llegar al \u00faltimo choque &lt;= E, y luego ah\u00ed es trivial calcular el dinero final. El problema de esto es que en el peor caso podr\u00eda pasar que hay que seguir muchos punteros y eso podr\u00eda dar TLE. Piensa en una forma de optimizar este proceso, quiz\u00e1s precomputando saltos exponenciales de punteros.  Soluci\u00f3n + c\u00f3digo   Para cada mes i y cota (U o L) precomputamos el siguiente choque (i', cota'). Esto se puede hacer con dos b\u00fasquedas binarias que en el predicado usen un sparse table de m\u00e1ximo o m\u00ednino sobre un arreglo accA (los ingresos de A acumulados). Para pegarnos saltos exponenciales, podemos crear un tercer sparse table que implemente binary lifting sobre los punteros obtenidos anteriormente. Para responder las Q queries (X,B,E) podemos hacer una b\u00fasqueda binaria inicial para encontrar el primer choque, luego hacer binary lifting para encontrar el \u00faltimo choque que no se pasa de E, y luego c\u00e1lcular el \u00faltimo cachito hasta E en O(1) haciendo restas de sumas acumuladas. C\u00f3digo de ejemplo"},{"location":"contests/hints/contest4/","title":"Contest 4 - hints y c\u00f3digos de ejemplo","text":""},{"location":"contests/hints/contest4/#a-troy-query","title":"A - TROY Query","text":"Hint 1   Noten que en vez de pensar en la cantidad de veces que cada fila/columna fue actualizada para llegar a la configuraci\u00f3n actual, s\u00f3lo importa la paridad de estas actualizaciones. Es decir, si fueron updateadas una cantidad par o impar de veces.  Hint 2   Si una celda es igual en ambos TROYS entonces fue actualizada una cantidad par de veces, s\u00f3lo hay 2 formas de que esto pase, que su fila y columna respectivas ambas hayan sido actualizadas una cantidad par de veces o que ambas hayan sido actualizadas una cantidad impar de veces (de esta forma la suma es par). De la misma forma, si la celda marca distinto entre los TROYS, la suma debe ser impar, por lo que una debe ser impar y la otra par. Piensen en c\u00f3mo llevar registro de estas implicancias de forma que sea f\u00e1cil chequear en caso de una contradicci\u00f3n.  Soluci\u00f3n + c\u00f3digo   Podemos registrar las implicancias como conjuntos de un Union Find. Es decir, generamos inicialmente 2 (R + C) conjuntos, dos para cada fila y columna, que representan la posibilidad de que sean par o impar. Cuando vemos el valor de una celda unimos los conjuntos correspondientes seg\u00fan el hint 2, de forma que conceptualmente estamos creando conjuntos de posibles valores que si pasan deben hacerlo juntos para no contradecir los registros. Si en alg\u00fan momento juntamos a una fila o columna par con su misma fila o columna impar entonces tenemos una contradicci\u00f3n, desde ese momento en adelante la respuesta es siempre \"No\".   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest4/#d-k12-bored-of-suffixes-and-prefixes","title":"D - K12-Bored of Suffixes and Prefixes","text":"Hint   Notemos que si mantenemos la matriz con valores correspondientes al n\u00famero de cada letra (A: 1, B: 2, ...) en vez de la letra en si, la consulta que se pide es equivalente a simplemente la suma en esa regi\u00f3n.  Soluci\u00f3n + c\u00f3digo   Podemos mantener registro segun el Hint en un Fenwick Tree 2D. Cada update ser\u00e1 realizar N updates a lo largo de la fila/columna correspondiente. Cada consulta ser\u00e1 devolver la suma en esa regi\u00f3n.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest4/#e-matrix-summation","title":"E - Matrix Summation","text":"Hint   Deben ocupar directamente una de las estructuras explicadas en clase en este problema.  Soluci\u00f3n + c\u00f3digo   Basta con ocupar directamente un Fenwick Tree 2D para sumas.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest4/#f-undetected","title":"F - UnDetected","text":"Hint   Podemos pensar que el momento en que ya no voy a ser capaz de cruzar el campo es cuando los robots activados cubren completamente el campo en una \"linea\", es decir separan la mitad inferior de la superior. Deben pensar en una forma de ir actualizando una estructura para cada sensor extra que agreguen de forma de poder detectar cuando se forme una barrera r\u00e1pidamente.  Soluci\u00f3n + c\u00f3digo   Podemos pensar en N + 2 conjuntos en un Union Find, uno por cada sensor y uno para el lado izquierdo y derecho del campo. Cada vez que activamos un sensor verificamos si choca con alguno de los lados o con alguno de los sensores activos, en caso de hacerlo unimos los conjuntos correspondientes. Si en alg\u00fan momento el conjunto correspondiente al borde izquierdo y al derecho son unidos, sabemos que se form\u00f3 una barrera y ya no se podr\u00e1 cruzar.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest4/#h-cut-inequality-down","title":"H - Cut Inequality Down","text":"Hint 1   Piensen en una forma de procesar las queries en orden de tal forma que con realizar s\u00f3lo una pasada por cada momento temporal podamos tener la respuesta a todas las queries.  Hint 2   Una opci\u00f3n es ir avanzando el tiempo desde el primer mes hasta el \u00faltimo procesando cuando corresponda distintos eventos. Estos pueden ser, el inicio de una query (con su monto inicial), y el fin de una query, donde guardamos el valor actual que tiene la query en ese momento. Debemos poder llevar cuenta del valor luego de las perdidas/ganancias en cada mes, sin pasarnos de los l\u00edmites.  Hint 3   Notemos que es muy ineficiente ir sumando la ganancia / p\u00e9rdida de cada mes a cada query activa, esa soluci\u00f3n es cuadr\u00e1tica y no pasa en tiempo, por lo que debemos optimizarla. Una opci\u00f3n es en vez de sumar a cada una, mantener una variable de offset que me guarde las ganancias acumuladas hasta el momento actual, luego el valor que tengo guardado m\u00e1s el offset ser\u00eda el verdadero valor de la query. Sin embargo tambi\u00e9n debemos ser capaces de ajustar cuando los valores de las queries activas se pasen de los l\u00edmites superior o inferior. Una forma de hacer esto es mantener los valores de las queries en un set ordenado, mientras el valor m\u00e1s grande se pase del l\u00edmite superior, sacamos del set, ajustamos y volvemos a insertar, similar en el l\u00edmite inferior. Notemos que a\u00fan hay problemas de tiempo en esta soluci\u00f3n, pues en el peor caso cada query activa se pasa de los l\u00edmites en cada tiempo, piensen en una forma de no tener que modificar tantas veces el set.  Hint 4   Una opci\u00f3n para arreglar el problema que se evidenci\u00f3 al final del hint 3 es usar un Union Find, de tal forma de s\u00f3lo guardar en el set un representante de cada conjunto del Union Find. Inicialmente podemos tener tantos conjuntos como Queries, sim embargo cuando sacamos cosas del set que se pasen del l\u00edmite inferior, sabemos que van a tener el mismo valor de ah\u00ed en adelante, por lo tanto nos basta con volver a ingresar s\u00f3lo uno de los que se hayan pasado, unir los conjuntos en el Union Find y al final de una query se guarda el valor que tiene el \u00edndice del padre de la query en el union find. Esto mejora la complejidad pues a lo m\u00e1s se unen una cantidad igual a la cantidad de queries.  Soluci\u00f3n + c\u00f3digo   La soluci\u00f3n consiste en implementar todas las ideas de los hints. Podemos implementar el orden de las queries en una priority_queue donde ordeno los inicios y t\u00e9rminos de queries. Mantendo en cada momento un set de pares ordenados con el valor de cada query activa y su \u00edndice, juntamos seg\u00fan el hint 3 si se pasan en alg\u00fan momento y retorno seg\u00fan corresponda.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest5/","title":"Contest 5 - hints y c\u00f3digos de ejemplo","text":""},{"location":"contests/hints/contest5/#a-lowest-common-ancestor","title":"A - Lowest Common Ancestor","text":"Hint   Problema de implementaci\u00f3n directa de LCA.  Soluci\u00f3n + c\u00f3digo C\u00f3digo de ejemplo"},{"location":"contests/hints/contest5/#b-minimum-spanning-tree","title":"B - Minimum Spanning Tree","text":"Hint   Problema de implementaci\u00f3n directa de MST.  Soluci\u00f3n + c\u00f3digo C\u00f3digo de ejemplo"},{"location":"contests/hints/contest5/#c-edges-in-mst","title":"C - Edges in MST","text":"Hint   En el algoritmo de kruskal para obtener el MST de un grafo, se procesan las aristas en orden de pesos y viendo la conectividad se llega siempre a la soluci\u00f3n. La \u00fanica parte en que podr\u00eda haber m\u00e1s de una soluci\u00f3n para un MST es si hay m\u00e1s de una arista con el mismo peso (y por tanto el procesamiento en kruskal es arbitrario en orden). Piensen en una forma de procesar las aristas con mismo peso simult\u00e1neamente para ver si cada una puede ser parte de una soluci\u00f3n.  Soluci\u00f3n + c\u00f3digo   Basta con usar el hint y simular el algoritmo de kruskal pero procesando todas las aristas del mismo peso simult\u00e1neamente. Si hay m\u00e1s de una aceptada del peso entonces es al menos en un MST (at least one), para estar en todos los MST posibles se debe cumplir adem\u00e1s que sin usarla el grafo queda desconexo necesarimente, para eso basta encontrar las aristas de corte en cada paso. Si no es aceptada es none.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest5/#d-tree-2","title":"D - Tree 2","text":"Hint 1   Si supieramos cual es el nodo m\u00e1s lejano a nosotros, bastar\u00eda con ver si la distancia entre yo y el es mayor o igual a k, de serlo devolvemos el k-\u00e9simo nodo en el camino y si no no existe nodo que cumpla lo pedido. Lamentablemente no podemos sacar distancias entre todos los nodos en tiempo, piensen en una forma de poder saber uno a mayor distancia r\u00e1pidamente.  Hint 2   Podemos obtener 2 nodos que esten lo m\u00e1s lejos posible uno del otro en el \u00e1rbol. Basta con hacer 2 dfs ambos encontrando nodos m\u00e1s lejanos, el primero de un nodo cualquiera y el segundo del nodo encontrado m\u00e1s lejos en el primero (as\u00ed encontramos el 2o). Estos dos nodos ser\u00e1n extremos de un di\u00e1metro de un \u00e1rbol y es m\u00e1s, podemos demostrar que para cualquier nodo (u) en el \u00e1rbol, se cumple que uno de los 2 nodos encontrados es lo m\u00e1s lejano a u posible. Usando esto y el hint 1 estamos casi listos. S\u00f3lo falta poder obtener distancia entre nodos y el k-\u00e9simo en un camino r\u00e1pidamente.  Soluci\u00f3n + c\u00f3digo   Para hacer lo \u00faltimo del hint 2 basta usar LCA, la distancia entre u y v es simplemente las profundidades de ambos nodos sumadas menos la profundidad del lca entre ellos. Para obtener el k-\u00e9simo nodo por otro lado basta hacer binary lifting usando la informaci\u00f3n de la sparse table de ancestros en el LCA. La complejidad final de este algoritmo es O(N) por los dfs iniciales m\u00e1s O(Q log N) por las queries usando LCA.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest5/#e-minimum-spanning-tree-for-each-edge","title":"E - Minimum spanning tree for each edge","text":"Hint   Se puede demostrar que dado un MST, para obtener el MST de un grafo forzando la aparici\u00f3n de una arista (e), siempre existir\u00e1 una arista (f) en el MST original tal que el \u00f3ptimo forzando e, es dado por MST - {f} + {e}. Luego basta encontrar el valor de esta arista f para cada arista a forzar.  Soluci\u00f3n + c\u00f3digo   Primero encontramos un MST original y luego para cada arista (u, v) tendremos: Si estaba ya en el MST no hacemos cambies y retornamos el valor del MST original. Si no est\u00e1 en el MST original basta con encontrar el valor de la mayor arista en el camino entre u y v en el MST original, el valor del MST forzado ser\u00e1 el el valor original m\u00e1s el de la arista forzada menos el de la encontrada en el camino. Para encontrar la mayor arista en un camino del MST basta con aplicar binary lifting en un LCA.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest5/#f-roads-in-hackerland","title":"F - Roads in HackerLand","text":"Hint 1   Notemos que en vez de considerar el grafo completo, basta considerar el MST obtenido al usar los C_i como pesos (en vez de 2^{C_i}). Esto pues si obtenemos el MST ordenando agregando desde las aristas de menor peso, entonces cualquier arista que no est\u00e9 en el MST ser\u00e1 sub\u00f3ptima, pues si no fue agregada al MST, por la construcci\u00f3n de Kruskal debe existir un camino entre los nodos que une con s\u00f3lo costos estrictamente menores. Y como en potencias de 2 distintas se cumple que la suma de potencias menores a k siempre es menor que 2^k, cualquiera de estos caminos ser\u00e1 \u00f3ptimo frente a pasar por la arista que no est\u00e1 en el MST.  Hint 2   Usando el MST del grafo, para obtener la soluci\u00f3n tenemos que saber la suma de todas las distancias de pares de nodos en binario. Notemos que podemos obtener las veces que cada arista en el MST ser\u00e1 usada usando un par de dfs. Primero usamos un dfs que precalcule los tama\u00f1os de cada sub\u00e1rbol y el segundo dfs ocupar\u00e1 esos valores para calcular cuantas veces se usa cada arista en el valor pedido (las veces que se usa una arista entre u y v es el tama\u00f1o del sub\u00e1rbol de v (S_v) multiplicado por su complemento N - S_v).  Soluci\u00f3n + c\u00f3digo   Teniendo los valores del Hint 2 s\u00f3lo queda obtener el n\u00famero binario, como cada arista tiene un valor de potencia de 2 distinto, si guardamos los valores mencionados anteriormente en un arreglo indexado por las potencias C_i, podemos convertir este arreglo en la respuesta binaria acumulando hacia arriba la divisi\u00f3n por dos del valor de cada celda (dejando registrado el resto). El arreglo resultante ser\u00e1 precisamente el n\u00famero binario pedido.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest5/#g-transportation-system","title":"G - Transportation system","text":"Hint   Para encontrar la cantidad de estados basta encontrar la cantidad de componentes conexas en el grafo impl\u00edcito que s\u00f3lo contiene aristas entre ciudades a distancia menor a r. Buscar componentes conexas se puede hacer f\u00e1cilmente con un DFS que marque visitados. Piensen en una forma de buscar el resto con lo visto en clases.  Soluci\u00f3n + c\u00f3digo   Para encontrar la menor extensi\u00f3n de caminos basta aplicar MST sobre el grafo impl\u00edcito donde todos son unidos con todos, la \u00fanica diferencia es que en vez de acumular las distancias en una variable global, debemos acumular por separado aquellos costos de caminos y trenes.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest5/#h-bmw","title":"H - BMW","text":"Hint 1   Notemos que el camino que buscamos es aquel donde el peso de la arista de menor peso sea m\u00e1ximo. Es decir, el camino con aristas de mayor peso (no necesariamente la suma ser\u00e1 mayor, sino que el m\u00ednimo es mayor).  Hint 2   Se puede demostrar que todas las aristas del camino que buscamos estar\u00e1n presentes en el Maximum Spanning Tree del grafo dado. Para encontrar el Maximum Spaning Tree basta ocupar el mismo algoritmo visto para el m\u00ednimo pero ordenando las ar\u00edstas de mayor a menor peso.  Soluci\u00f3n + c\u00f3digo   La soluci\u00f3n consiste en implementar un dfs que busque el camino con mayor m\u00ednimo, este dfs s\u00f3lo funciona en tiempo lineal si el grafo sobre el que trabaja es un \u00e1rbol sin ciclos, por eso trabajamos sobre el Maximum Spanning Tree seg\u00fan el hint 2.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest6/","title":"Contest 6 - Hints y c\u00f3digos de ejemplo","text":""},{"location":"contests/hints/contest6/#a-submerging-islands","title":"A - Submerging Islands","text":"Hint   Problema directo de contar puntos de articulaci\u00f3n en el grafo  Soluci\u00f3n + c\u00f3digo   Ojo, usen un set para contar cuantos hay, si aumentan una variable contar\u00e1n repetido.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest6/#b-hegde-mazes","title":"B - Hegde Mazes","text":"Hint   Si s\u00f3lo existe un camino simple que une S y T entonces removiendo cualquier arista en el camino los nodos S y T quedar\u00e1n desconectados, es decir, todas las aristas del camino que buscamos deben ser aristas de corte.  Soluci\u00f3n + c\u00f3digo   Basta saber si existe un camino entre S y T que use s\u00f3lo aristas de corte, para esto podemos usar Union Find uniendo dos nodos si hay una arista de corte entre ellos. Luego la respuesta es si los nodos est\u00e1n unidos en el union find o no.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest6/#c-checkposts","title":"C - Checkposts","text":"Hint   Si es posible ir a un nodo y volver, entonces ambos deben pertenecer a la misma componente fuertemente conexa.  Soluci\u00f3n + c\u00f3digo   Basta con encontrar las componentes fuertemente conexas y calcular lo pedido usando las inesecciones de menos costo en cada una. El costo final ser\u00e1 la suma de los menores costo y las formas de hacerlo ser\u00e1 la multiplicaci\u00f3n de cuantas intersecciones ten\u00edan ese menor costo en cada componente.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest6/#d-good-travels","title":"D - Good Travels","text":"Hint   Notemos que si en el camino \u00f3ptimo que buscamos se pasa por un nodo u, siempre ser\u00e1 posible pasar por todos los nodos en la misma componente fuertemente conexa que u. De esta forma podemos como primer paso reducir el grafo original a un grafo alterno donde cada nodo corresponde a una componente fuertemente conexa en el grafo original y s\u00f3lo nos quedamos con aristas que vayan de una componente a otra. Podemos asignar valor de diversi\u00f3n (fun) de cada componente como la suma de la diversi\u00f3n de los nodos que la componen.  Soluci\u00f3n + c\u00f3digo   Haciendo uso del hint, es conocido que el grafo resultante debe ser un DAG (directed acyclic graph). Luego podemos obtener la respuesta pedida usandoi un DP sobre el grafo construido, donde devolvemos la maxima suma de diversiones en un camino de componentes que termine en la componente que corresponda a la ciudad de destino.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest6/#e-capital-city","title":"E - Capital City","text":"Hint   Notemos que si una ciudad es candidata a ser capital, todas las ciudades en la misma componente fuertemente conexa deben serlo, luego basta con saber si alguna de las ciudades en cada componente fuertemente conexa puede ser capital.  Soluci\u00f3n + c\u00f3digo   Para chequear si una ciudad puede ser capital basta correr un DFS desde la cuidad en el grafo con las aristas invertidas, si se puede llegar a todos los nodos es porque todos pod\u00edan llegar a ella por lo que puede ser capital.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest6/#f-jobbery","title":"F - Jobbery","text":"Hint 1   Notemos que si construimos el grafo dirigido que modela las relaciones, si una persona es peligrosa, todas las personas en su misma componente fuertemente conexa tambi\u00e9n ser\u00e1n peligrosas, pues pueden llegar a la primera persona y por tanto a todas las que \u00e9l llega.  Hint 2   Podriamos buscar las componentes fuertemente conexas y correr un dfs que cuente el alcance de cada una, pero esto no pasar\u00eda en tiempo. Pensemos en una forma de s\u00f3lo hacer un dfs de conteo. Noten que siempre la primera componente fuertemente conexa que se encuentra con Tarjan ser\u00e1 la m\u00e1s profunda en ese \u00e1rbol de exploraci\u00f3n. Adem\u00e1s podemos notar que la componente que buscamos es la menos profunda en el grafo.  Soluci\u00f3n + c\u00f3digo    Usando los hints podemos ver que podemos aprovecharnos de la naturaleza del algoritmo de tarjan y buscar las componentes en el grafo inverso, de esta forma la primera que encontremos es la \u00fanica candidata a contener a las personas peligrosas (pues es la m\u00e1s profunda del grafo inverso y por lo tanto la menos del grafo original). una vez encontrada corremos un dfs de conteo en el grafo normal y dejamos de buscar m\u00e1s componentes. si se cont\u00f3 que la componente llegaba a todo el grafo, devolvemos a sus miembros como respuesta.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest6/#g-leaders","title":"G - Leaders","text":"Hint 1   Notemos que de ser posible ir de un nodo a otro, para que haya un camino simple de largo impar podemos o ir directo pasando por una cantidad impar de aristas o pasar por una componente biconexa con un ciclo impar (la segunda opci\u00f3n siempre tendr\u00e1 un camino simple que cumpla lo pedido). Si en el camino entre u y v se pasa por una componente biconexa con un ciclo impar la respuesta ser\u00e1 siempre positiva, de lo contrario basta con bicolorear el grafo y ver si u y v son de colores distintos.  Hint 2   Para encontrar componentes biconexas con ciclo impar basta ocupar el mismo dfs que encuentra las componentes pero ir bicoloreando y recordando si los backedges iban a un nodo del mismo color o no, de hacerlo marcan un ciclo impar y al removerlas la componente tiene un ciclo impar.  Soluci\u00f3n + c\u00f3digo   La soluci\u00f3n consiste en buscar bicomponentes con ciclos de largo impar y removerlas del grafo. Si dos nodos estaban conexos previo a la remoci\u00f3n y despu\u00e9s no, es porque su camino pasaba por una de estas componentes por lo que la respuesta ser\u00e1 \"Yes\". En caso de seguir conectadas la respuesta depender\u00e1 de si son del mismo color o no.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest7/","title":"Contest 7 - Hints y c\u00f3digos de ejemplo","text":""},{"location":"contests/hints/contest7/#a-attacking-rooks","title":"A - Attacking Rooks","text":"Hint   Podemos ver poner una torre como el equivalente de emparejar una subfila con una subcolumna. Luego maximizar las torres es equivalente a maximizar parejas (maximum bipartite matching).  Soluci\u00f3n + c\u00f3digo  Armamos un grafo bipartito donde un grupo son las subfilas y otro las subcolumnas, con aristas conectando subfilas con subcolumnas que tienen una celda en com\u00fan. Luego resolvemos maximum bipartite matching con maxflow. C\u00f3digo de ejemplo"},{"location":"contests/hints/contest7/#b-hooligan","title":"B - Hooligan","text":"Hint 1   Obviamente, de partida nos conviene ponernos en el caso optimista de que el equipo 0 gana todos sus partidos pendientes.  Hint 2   Pensar que cada par de equipos (i, j) involucra una candidad K_(i,j) de partidos pendientes entre ellos y por ende 2 x K_(i,j) puntos a repartir. Es decir, podemos verlo como que el par (i,j) debe \"bombear\" 2 x K_(i, j) puntos a i y j. Por otro lado, como queremos que el equipo 0 gane, si el equipo 0 tiene P_0 puntos y el equipo i tienes P_i puntos, entonces el equipo i a lo m\u00e1s puede recibir P_i - P_0 - 1 puntos.  Soluci\u00f3n + c\u00f3digo   Primero asumimos que el equipo 0 gana todos su partidos pendientes (hint 1). Luego armamos un grafo para maxflow seg\u00fan el hint 2: un source, una capa de nodos (i,j) correspondientes a pares de equipos ((N-2)x(N-1)/2 nodos), una capa de N-1 nodos (equipos) y un target. Las capacidades desde el source son los puntos pendientes a repartir por cada par de equipos, las capacidades hacia el target son las cotas P_i - P_0 - 1 de puntaje extra por equipo. Si el flujo m\u00e1ximo de la red es igual al total de puntaje pendiente, quiere decir que es posible jugar todos los partidos de tal manera que el equipo 0 gane. De lo contrario, no se puede. C\u00f3digo de ejemplo"},{"location":"contests/hints/contest7/#c-kill-the-werewolf","title":"C - Kill the Werewolf","text":"Hint 1   Piensen en como contar los que no tienen oportunidad de ganar en vez de los que si la tengan  Hint 2   Supongamos que analizamos las posibilidades de la i-\u00e9sima persona, suponiendo que todos los que la eligieron en primera fase votan por ella en 2a fase, la \u00fanica forma de ganar es que con los otros votos mas el de la i-\u00e9sima persona haya alguien que acumule al menos tantos votos como la i-\u00e9sima. Luego para que no tenga oportunidad debe haber una forma de repartir los votos en que nadie llegue al l\u00edmite de la cantidad de votos que recibe la i-\u00e9sima persona.  Soluci\u00f3n + c\u00f3digo   Usando los hints se analiza la posibilidad de cada persona 1 a 1, para chequear generamos un grafo bipartito con 2 nodos por persona para flujo m\u00e1ximo, unimos las personas que no eligieron a la i-\u00e9sima en primera fase con sus posibles votos. le damos capacidad 1 a todas las aristas de la fuente y de los posibles votos pero ajustamos las capacidades al destino para impedir que se pueda tener m\u00e1s o igual votos que los que tendr\u00e1 la i-\u00e9sima persona. Si el flujo m\u00e1ximo es igual a la gente considerada en el grafo es porque pueden impedir que la i-\u00e9sima persona gane.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest7/#d-domino-art","title":"D - Domino Art","text":"Hint   Notemos que si coloreamos las celdas del tablero como ajedrez, una pieza de domin\u00f3 siempre une celdas de colores opuestos, luego si existe una forma de cubrir con dominos entonces todas las celdas de color negro debe poder conectarse a una blanca sin traslapar.  Soluci\u00f3n + c\u00f3digo   Usando el hint podemos chequear la existencia de un cubrimiento con un problema de flujo donde unimos a la fuente las celdas de color negro con capacidad 1, luego unimos las celdas negras que nos importan a las blancas que nos importan adyacentes, luego unimos las blancas que nos importan al destino con capacidad uno, si el flujo es igual a la mitad de las celdas que nos importan entonces es posible cubrir la figura.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest7/#f-in-case-of-an-invasion-please","title":"F - In Case of an Invasion, Please","text":"Hint 1   Intenten una b\u00fasqueda binaria sobre la respuesta.  Hint 2   En la b\u00fasqueda binaria, dado un tiempo tratamos de ver si la respuesta es posible con un problema de flujo m\u00e1ximo, para eso podemos intentar unir lugares a refugios si es posible llegar a ellos en el tiempo, es posible saber si es posible ir a cada refugio en el tiempo sin empeorar la complejidad preprocesando las distancias a los refugios con un Dijkstra.  Soluci\u00f3n + c\u00f3digo   Usando los hints anteriores la soluci\u00f3n consiste en hacer b\u00fasqueda binaria sobre la respuesta y para checkear generamos un grafo para flujo m\u00e1ximo tirando aristas de la fuente a los nodos con su capacidad entregada in aristas de capacidad infinita de los nodos a los refugios que se alcancen en el tiempo de la b\u00fasqueda seg\u00fan el dijkstra preprocesado. Si el flujo es igual a la cantidad de personas totales se aprueba la condici\u00f3n. Sin embargo para que pase en tiempo se necesita una optimizaci\u00f3n extra uniendo aquellas posiciones que pueden llegar a los mismos refugios.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest7/#g-surely-you-congest","title":"G - Surely You Congest","text":"Hint 1   Se puede observar que si dos lugares tienen distancias m\u00ednimas al destino distintas entonces no hay forma de que choquen en el camino si van s\u00f3lo por caminos \u00f3ptimos.  Hint 2   Dado que tengamos las distancias al destino precalculadas (con un algoritmo como dijkstra), podemos asegurarnos de usar s\u00f3lo aristas que sean \u00f3ptimas usando aquellas que mantengan distancias \u00f3ptimas del dijkstra a traves de ellas. A esta t\u00e9cnica se le conoce como usar el DAG de caminos \u00f3ptimos.  Soluci\u00f3n + c\u00f3digo   Por el hint 1, podemos procesar las posiciones por distancia al destino pero procesando los que est\u00e9n a distancias iguales al mismo tiempo, para saber cuantas personas pueden llegar a destino de las que se procesan en alg\u00fan momento podemos plantear un problema de flujo m\u00e1ximo, podemos tirar aristas de flujo 1 a todas las posiciones que tengan misma distancia (1 por cada persona en ellas) adem\u00e1s usamos aristas de capacidad 1 en los caminos \u00f3ptimos del hint 2. A la respuesta se le suma el flujo m\u00e1ximo en cada procesamiento.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest8/","title":"Contest 8 - Hints y c\u00f3digos de ejemplo","text":""},{"location":"contests/hints/contest8/#a-queries-for-number-of-palindromes","title":"A - Queries for Number of Palindromes","text":"Hint 1   Dado el tama\u00f1o del string podemos preprocesar todos los substrings cuadr\u00e1ticamente para saber cu\u00e1les conforman pal\u00edndromos, esto puede ser chequeado con Rolling Hashing hacia ambos lados por ejemplo. Piensen en c\u00f3mo usar este preprocesamiento para obtener la soluci\u00f3n.  Hint 2   Dados l y r, la cantidad de substrings en [l, r] es la cantidad en [l, r - 1] m\u00e1s la en [l + 1, r] menos la en [l + 1, r - 1] m\u00e1s 1 si el mismo substring [l, r] era un pal\u00edndromo.  Soluci\u00f3n + c\u00f3digo   Usando los hints anteriores se puede armar un algoritmo de programaci\u00f3n din\u00e1mica que cuente los substrings que son pal\u00edndromos para cada l y r usando la recursi\u00f3n del hint 2.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest8/#b-cellphone-typing","title":"B - Cellphone Typing","text":"Hint   Si comprimimos todo en un trie, \u00bfse te ocurre una forma f\u00e1cil de resolver el problema?  Soluci\u00f3n + c\u00f3digo   Metemos todas las palabras en un trie, y en cada nodo contamos la frecuencia de palabras que pasaron por ese nodo. Luego, simulamos el proceso de tipear cada palabra navegando el trie desde la ra\u00edz y usando los caracteres de la palabra como las instrucciones de navegaci\u00f3n. Partimos sumando 1 porque el primer caracter siempre se tipea. Luego, los siguientes caracteres se autocompletan si y s\u00f3lo si la transici\u00f3n en el trie es obligada (si el nodo anterior solo tiene un puro hijo), esto se puede chequear comparando los contadores, si son iguales no hay bifurcaciones. Al final dividimos la suma total por la cantidad de palabras. C\u00f3digo de ejemplo"},{"location":"contests/hints/contest8/#c-efficient-managing","title":"C - Efficient managing","text":"Hint 1   Primero notemos que el grafo descrito corresponde a un \u00e1rbol. En ese caso podemos precalcular el precio de viajar desde un nodo ra\u00edz a cualquiera de los otros nodos en tiempo lineal con un dfs. Basta hacer un dfs que acumule el xor de las aristas usadas, pues el xor de los valores s\u00f3lo tiene aquellas potencias de 2 con apariciones impares.  Hint 2   Notemos que si estamos analizando el nodo i, cualquier camino desde i se puede ver como parte del sub\u00e1rbol de i en el arbol con la ra\u00edz original o puede ser un camino que sube y luego baja por el \u00e1rbol, en ambos casos, cualquier camino que salga de i tendr\u00e1 un costo igual al xor del camino precalculado desde la ra\u00edz hasta i xor con el precalculado de la ra\u00edz al nodo final del camino tomado desde i. Luego el problema puede ser reformulado a precalcular como el hint 1 y para cada i encontrar cual de los valores precalculados genera un mayor xor al ser combinados con el precalculado para i.  Hint 3   Finalmente noten que cada uno de los valores precalculados puede ser cisto como un string binario, para encontrar el que genera el mayor xor con otro de estos strings, digamos x, se puede tomar un approach greedy que va condicionando tomar aquellos n\u00fameros con bits m\u00e1s grandes que difieran a los de x. Para esto piensen en qu\u00e9 estructura les deja ordenar los strings por los valores separando cada vez que difieren.  Soluci\u00f3n + c\u00f3digo   La soluci\u00f3n corresponde a usar la reducci\u00f3n de los hints 1 y 2 y hacer un Trie de los strings binarios descritos en el hint 3. El Trie recibir\u00e1 los valores precalculados en forma binaria pero los ingresar\u00e1 al Trie con los bits m\u00e1s grandes al principio. Esto pues podemos encontrar el mayor xor posible con los n\u00fameros guardados con respecto a un n\u00famero x usando un approach greedy que elija bits distintos siempre que se pueda en el trie (analizando desde bits m\u00e1s grandes a menos igual que como fueron ingresados).   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest8/#d-death-stars-medium","title":"D - Death Stars (medium)","text":"Hint   Piensa en una forma de acelerar la comparaci\u00f3n entre strings.  Soluci\u00f3n + c\u00f3digo   Usamos rolling hashing. Creamos una instancia de la clase hash por cada fila de la matriz vertical y por cada fila de la matriz horizontal. Luego hacemos un doble for y en cada caso con un tercer for hacemos M comparaciones aprovechando los hashes para ver si las submatrices de MxM coinciden. Para hacer el c\u00f3digo m\u00e1s r\u00e1pido, hacemos break del tercer for apenas algo no coincida. C\u00f3digo de ejemplo"},{"location":"contests/hints/contest8/#e-isomorphic-inversion","title":"E - Isomorphic Inversion","text":"Hint   Piensen en una forma greedy de seleccionar los segmentos.  Soluci\u00f3n + c\u00f3digo   Podemos armar los segmentos de forma greedy chequenando con k de 1 creciente separando los primeros y \u00faltimos k cada vez que el sustring de los primeros k que quedan sea igual al de los \u00faltimos k. Para chequear esto se puede usar hashing preprocesado de todo el string. la respuesta ser\u00e1 cuantas veces se pudo separar * 2 m\u00e1s uno si sobraron cosas al medio.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest8/#f-diccionario-portunol","title":"F - Diccion\u00e1rio Portu\u00f1ol","text":"Hint 1   Podemos pensar el problema como descontar de la cantidad de combinaciones totales todos los que se repitan.  Hint 2   Para contar las totales podemos contar cada prefijo en portugu\u00e9s posible usando un Trie de las palabras en portug\u00faes, y para la cantidad de sufijos en espa\u00f1ol podemos usar un Trie de las palabras en espa\u00f1ol reversas (as\u00ed no repetimos sufijos). Luego la cantidad de nodos usados en cada trie multiplicados es la cantidad total de combinaciones prefijo sufijo posibles. S\u00f3lo queda descontar las que se repitan.  Hint 3   La \u00fanica forma de que estemos contando combinaciones repetidas es que haya un prefijo en portug\u00faes que termine con la misma letra que empieza un sufijo en espa\u00f1ol, as\u00ed se podr\u00eda tomar esa letra indist\u00edntamente de ambos lados. Podemos precaluclar cuantos prefijos portugueses terminan en cada letra f\u00e1cilmente usando un dfs sobre los nodos del trie. Lo mismo para las primeras letras de los sufijos en espa\u00f1ol.  Soluci\u00f3n + c\u00f3digo   La soluci\u00f3n consiste en descontar de lo contado seg\u00fan hint 1 las repeticiones como mencionadas en el hint 2. Para contarlas hacemos 2 dfs, uno que cuente prefijos en portugu\u00e9s terminados en cada letra (prefijos de largo mayor a 1 pues no puede ser vac\u00edo seg\u00fan enunciado y estamos contando repeticiones donde tomamos o no la \u00faltima letra). En el otro dfs cada vez que encontramos un sufijo que empieze en una letra, descontamos de la respuesta la cantidad de prefijos que terminaban en ella.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest8/#g-dr-evil-underscores","title":"G - Dr. Evil Underscores","text":"Hint   Piensa que los n\u00fameros son strings de largo 30 en binario y con padding de 0's por la derecha de ser necesario. Piensa ahora que los metes en un trie. \u00bfSe te ocurre c\u00f3mo resolver el problema?  Soluci\u00f3n + c\u00f3digo   Armamos un trie con los n\u00fameros como lo sugiere el hint. Luego podemos encontrar el m\u00ednimo xor con un DFS sobre el trie desde la ra\u00edz. El DFS va a calcular el m\u00ednimo xor posible desde el nodo u. Si u tiene un puro hijo, entonces siempre podemos escoger el mismo bit para que en el xor nos de 0. Si u tienes dos hijos, entonces independiente de cu\u00e1l bit escogamos, en el m\u00e1ximo siempre va a convenir escoger la rama con el bit opuesto, entonces siempre va a haber un bit prendido en la i-\u00e9sima posici\u00f3n (donde i es la profundidad del nodo u) y luego escogemos el m\u00ednimo entre los dos DFS's de los hijos. C\u00f3digo de ejemplo"},{"location":"contests/hints/contest9/","title":"Contest 9 - Hints y c\u00f3digos de ejemplo","text":""},{"location":"contests/hints/contest9/#a-string-tale","title":"A - String Tale","text":"Hint   Hay una soluci\u00f3n trivial con KMP.  Soluci\u00f3n + c\u00f3digo   Concatena el primer string dos veces, busca la primera aparici\u00f3n del segundo string en el primer string usando KMP. Luego calcular el shift es trivial. C\u00f3digo de ejemplo"},{"location":"contests/hints/contest9/#b-gluing-pictures","title":"B - Gluing Pictures","text":"Hint 1   Noten que basta usar un approach greedy donde vamos completando la palabra buscado usar substrings lo m\u00e1s grandes posibles del string grande. Esto siempre ser\u00e1 \u00f3ptimo, s\u00f3lo queda saber c\u00f3mo buscar el mayor substring que podemos tomar de forma eficiente.  Hint 2   Podemos buscar lo descrito en el hint 1 letra por letra. Dado que hayamos precalculado el suffix array del string original, en este tendremos ordenados los sufijos. Todo substring debe ser el prefijo de un sufijo, luego basta buscar el sufijo que tenga un prefijo com\u00fan m\u00e1s grande. Piensen c\u00f3mo hacerlo letra por letra usando b\u00fasqueda binaria.  Soluci\u00f3n + c\u00f3digo   Podemos buscar letra por letra con b\u00fasqueda binaria, inicialmente l = 0, r = N y tenemos todos los sufijos, hacemos b\u00fasqueda binaria por una letra y podemos reducir el rango a l', r' donde todos los sufijos en [l', r') comparten la primera letra con el string buscado, luego acotamos este nuevo rango seg\u00fan la segunda letra y as\u00ed sucesivamente. En el momento donde no podamos encontrar una letra habremos encontrado el substring m\u00e1s largo posible, agregamos uno a la respuesta y empezamos de nuevo del rango [0, N) con la letra que quedamos.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest9/#c-prefixes-and-suffixes","title":"C - Prefixes and Suffixes","text":"Hint 1   En este problema sirve usar suffix array y el arreglo LCP (longest common prefix). En particular, piensa en un prefijo que tambi\u00e9n es sufijo y adem\u00e1s aparece varias veces m\u00e1s como substring. Los respectivos sufijos aparecen todos juntitos en el suffix array. Adem\u00e1s, si miramos los valores del arreglo LCP se pueden ver como las columnas de un histograma, notaremos que el largo del substring corresponde a la altura de la columna m\u00e1s baja en el rango, y que las columnas a las izquierda y a la derecha del rango son altura estrictamente menor.  Hint 2   Del hint 1, podemos inferir una estrategia: vemos al arreglo LCP como histograma y buscamos rangos de columnas donde una columan en particular es la altura m\u00ednima (el largo del substring), todas las dem\u00e1s son &gt;= a ese rango, y las columnas antes y despu\u00e9s del rango son de altura menor estricta. Luego bastar\u00eda verificar que entre los sufijos del rango se encuentren el sufijo 0 (prefijo) y un sufijo de largo igual a la columna m\u00e1s baja del rango.  Soluci\u00f3n + c\u00f3digo   Generamos un suffix array + LCP a partir del string de input. Luego encontramos los rangos maximales de columnas en el arreglo LCP que se mencion\u00f3 en los hints. Para ello, la idea es fijar la columna i-\u00e9sima como la m\u00e1s baja, y luego encontrar los extremos L[i] y R[i] del correspondiente rango de columnas. Este se puede hacer en O(N) con dos pasadas lineales + un stack (descubrir/googlear como resolver linealmente este problema: ). Luego, necesitamos saber el primer y \u00faltimo sufijo en cada rango. Esto se puede hacer en O(1) usando dos sparse tables para obtener el m\u00ednimo y m\u00e1ximo por rango. Luego basta verificar si el m\u00ednimo es 0 y el m\u00e1ximo + LCP[i] es N. Para evitar duplicados, recolectamos los pares en un set de pares (que de paso nos ordena los pares gratis), y adem\u00e1s agregamos el par que siempre va: (N, 1). Finalmente, imprimimos los pares. C\u00f3digo de ejemplo"},{"location":"contests/hints/contest9/#d-string-similarity","title":"D - String Similarity","text":"Hint   Noten que si calulamos el suffix array con arreglo lcp del string original ya se tiene calculado el tama\u00f1o de los longuest common preffix de sufijos continuos en el suffix array. Piensen en c\u00f3mo ocupar esto para obtener la respuesta.  Soluci\u00f3n + c\u00f3digo   Podemos buscar el lugar donde est\u00e1 el string completo en el suffix array (buscar la posici\u00f3n del 0). Luego la respuesta ser\u00e1 la suma de acumular m\u00ednimos hacia derecha e izquierda del arreglo lcp, esto pues el largo com\u00fan de un segmento continuo del suffix array corresponde al m\u00ednimo de los lcp del rango.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest9/#e-marblecoin","title":"E - Marblecoin","text":"Hint 1   Notar que el impuesto a pagar se puede pensar como un n\u00famero en base 365. Por lo tanto, nos conviene que los d\u00edgitos m\u00e1s significativos sean lo m\u00e1s chicos posibles. Esto implica que nos conviene escoger el tope de stack m\u00e1s chico. \u00bfPero qu\u00e9 pasa si hay empate?  Hint 2   Si hay empates, entonces nos convendr\u00eda desempatar escogiendo el tope de stack que deja debajo suyo el n\u00famero m\u00e1s chico. Si hay empate de nuevo, el que debajo el n\u00famero m\u00e1s chico, y as\u00ed sucesivamente. \u00bfQu\u00e9 pasa si 2 stacks empatan en todo pero uno se acaba antes que el otro (en otras palabras, qu\u00e9 pasa si un stack es prefijo de otro)?  Hint 3   Si un stack es prefijo de otro, nos conviene priorizar el stack m\u00e1s largo, ya que ese stack a largo plazo nos da m\u00e1s opciones para escoger (en ning\u00fan caso es peor escoger el m\u00e1s largo, o da lo mismo o nos conviene).  Hint 4   Piensa en alguna estructura de datos para hacer comparaciones lexicogr\u00e1ficas eficientes entre stacks.  Soluci\u00f3n + c\u00f3digo   Concatenamos todos los stacks en un puro string, poniendo como caracter separador y al final el 301 (o cualquier otro valor que sea mayor estricto a todos los caracteres). Luego construimos un suffix array sobre dicho string. De esta manera, el arreglo rank del suffix array nos permite comparar en O(1) los sufijos de dos stacks desempatando de la forma en que nos interesa seg\u00fans los hints (notar que el 301 es clave para priorizar stacks m\u00e1s largos). Luego, el problema se reducen simular el proceso de ir sacando topes de stacks, lo cual podemos hacerlo con una priority_queue donde priorizamos los topes de stacks con rank m\u00e1s bajos, y al sacar un tope de stack metemos el tope que queda debajo. C\u00f3digo de ejemplo"},{"location":"contests/hints/contest9/#f-lucky-common-subsequence","title":"F - Lucky Common Subsequence","text":"Hint   Noten que si no existiera el virus, el problema de encontrar la mayor subsecuencia com\u00fan se puede resolver usando un dp cuadr\u00e1tico con estados i, j, correspondientes a las posiciones que estamos revisando de cada string, luego la recursi\u00f3n es en (i, j) considerar dp(i + 1, j), dp(i, j + 1) y si S1[i] == S[j] considerar 1 + dp(i + 1, j + 1) (retornando el m\u00e1ximo). La respuesta es dp(0, 0). Piensen en c\u00f3mo adaptar esta recursi\u00f3n para detectar cuando se complete un virus y evitarlo.  Soluci\u00f3n + c\u00f3digo   Podemos usar un approach como KMP, en este algoritmo se recorre un string linealmente y se puede detectar cuando aparece otro string dentro, podemos usar este mismo m\u00e9todo para detectar si con las letras que se han usado (cuando se pas\u00f3 a (i + 1, j + 1) en la recursi\u00f3n) se arma el virus. Basta agregar un estado extra al dp que haga referencia al \u00edndice del arreglo lps actual.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest9/#g-match-catch","title":"G - Match &amp; Catch","text":"Hint     Piensen en c\u00f3mo se puede responder lo pedido usando el prec\u00e1lculo de un suffix array y lcp. Noten que todo substring es un prefijo de un sufijo, y para que sea \u00fanico en el string original basta con que sea de largo mayor al lcp anterior y posterior (pues no habr\u00e1 otro prefijo de sufijo igual de ese largo).  Soluci\u00f3n + c\u00f3digo   Podemos usar el hint 1 pero precalculando sobre el string S1#S2, as\u00ed podemos filtrar los substrings comunes y unicos de ambos mirando el lcp, de forma que ser\u00e1n continuos en el suffix array pero los lcp inmediatamente posterior y anterior ser\u00e1n menores. Es decir, si estamos en la posici\u00f3n i del suffix array, donde sa[i] es parte de S1 y sa[i + 1] es parte de S2. luego el menor substring com\u00fan asociado a esa posici\u00f3n debe ser de largo menor o igual a lcp[i], pero s\u00f3lo ser\u00e1 unico en ambos strings si lcp[i] &gt;= largo &gt; max(lcp[i - 1], lcp[i + 1]). Luego si es posible tomamos largo = max(lcp[i - 1], lcp[i + 1]) + 1, y nos quedamos con el menor de estos largos.   C\u00f3digo de ejemplo"},{"location":"contests/hints/contest9/#h-file-retrieval","title":"H - File Retrieval","text":"Hint 1 <p>Supongamos que tenemos varios archivos y tipeamos una query Q = \"blabla\", y nos aparece una lista de todos los matches de \"blabla\" en todos los archivos en la forma de pares (File ID, Match Index). Todos esos matches son posiciones donde \"blabla\" es un substring de un archivo, o en otras palabras, \"blabla\" es prefijo de un sufijo de alg\u00fan archivo. Ahora, supongamos que juntamos todos los sufijos de todos los archivos, los metemos a una lista y los ordenamos lexicogr\u00e1ficamente: \u00bfC\u00f3mo se ven los matches ahora?</p> <p>**SPOILER: todos los sufijos donde \"blabla\" es prefijo aparecen juntos en la lista (un segmento contiguo de la lista) </p> Hint 2   Concatenemos todos los archivos en un string largo usando caracteres separadores especiales, y construyamos un Suffix Array sobre el string. Construyamos el arreglo LCP (longest common prefix) tambi\u00e9n. Ahora volvamos al ejemplo de la query \"blabla\". El rango contiguo donde \"blabla\" hace match es un intervalo maximal de sufijos consecutivos donde todos tienen como prefijo \"blabla\". Supongamos que este intervalo es [L, R]. Esto implica que LCP[i] &gt;= len(\"blabla\") para i = L, L+1, ..., R-1, y adem\u00e1s LCP[L-1] &lt; len(\"blabla\") y LCP[R] &lt; len(\"blabla\"). Notar que el intervalo [L,R] generado por la query Q = \"blabla\" es equivalente al intervalo generado por query Q' = (\"blabla\" + algun_extra) que se obtiene alargando Q por la derecha tal que len(Q') = min { LCP[i] para i = L, ..., R-1 }. Si visualizamos el arreglo LCP como un histograma, Q hace match con un rect\u00e1ngulo horizontalmente maximal, y Q' es b\u00e1sicamente aumentar la altura de dicho rect\u00e1ngulo hasta chocar con la columna m\u00e1s chica del histograma.  Hint 3 <p>El resumen del Hint 2 es que toda query tiene una query equivalente que corresponde a un rect\u00e1ngulo maximal en el \"histograma\" del arreglo LCP (un rect\u00e1ngulo que no podemos hacer m\u00e1s alto ni m\u00e1s ancho sin salirnos del histograma). Por lo tanto, todos los \"searchable subsets\" son los archivos distintos que aparecen en el rango de alg\u00fan rect\u00e1ngulo maximal del arreglo LCP.</p> <p>** Hay un caso borde: lo dicho anteriormente es verdad de las querys que hacen match en 2 o m\u00e1s sufijos, \u00bfpero qu\u00e9 pasa con las queries que hacen match con exactamente un solo sufijo?</p> Soluci\u00f3n + c\u00f3digo   En breve: concatenamos todos los files en un puro string. Construimos un suffix array y el arreglo LCP. Vemos el arreglo LCP como histograma y encontramos rect\u00e1ngulos maximales usando un approach de stacks similar al que se usa para resolver este problema: bas\u00edcamente por cada columna i-\u00e9sima suponemos que es el techo de un rect\u00e1ngulo maximal, y encontramos los extremos L[i] y R[i] donde comienza y termina el rect\u00e1ngulo. Para obtener los archivos distintos que aparecen en ese rango, podemos usar bitmasks y un sparse table para computar el OR en el rango en O(1), aprovechando el hecho de que son a lo m\u00e1s 60 archivos lo que nos cabe en un long long int (64 bits). Para las queries que hacen match con un solo sufijo, iteramos por todos los sufijos y vemos si LCP[i-1] &lt; len(sufijo[i]) y LCP[i] &lt; len(sufijo[i]). Todos los searchable subsets que encontremos los metemos a un set y finalmente retornamos el tama\u00f1o. C\u00f3digo de ejemplo"},{"location":"notes/geometry/base_implementation/","title":"Implementaci\u00f3n Base","text":"<p>Para trabajar con puntos, vectores, pol\u00edgonos, etc en programaci\u00f3n competitiva vamos a crear una estructura propia basada en la del libro Handbook of geometry for competitive programmers.</p>"},{"location":"notes/geometry/base_implementation/#operaciones-basicas","title":"Operaciones b\u00e1sicas","text":"<p>Partimos definiendo la estructura con la que vamos a trabajar y unas operaciones b\u00e1sicas.</p> <p> </p> <pre><code>typedef double T;   // (1)!\nstruct pt {\nT x,y;\npt operator+(pt p) {return {x+p.x, y+p.y};}\npt operator-(pt p) {return {x-p.x, y-p.y};}\npt operator*(T d) {return {x*d, y*d};}\npt operator/(T d) {return {x/d, y/d};}\n};\n</code></pre> <ol> <li> Se puede cambiar por <code>int</code> o <code>long long</code> seg\u00fan sea necesario.</li> </ol> <p>Entonces, podemos crear puntos y operar de la siguiente forma:</p> <p> </p> <pre><code>pt a = {1, 2};   // (1)!\npt b = {3, 4};\npt c = a + b; // {4, 6}\npt d = a - b; // {-2, -2}\npt e = a * 2; // {2, 4}\npt f = a / 2; // {0.5, 1}\n/*(2)!/*\n</code></pre> <ol> <li> As\u00ed se creamos un punto. </li> <li> Nuestra implementaci\u00f3n nos permite operar de forma intuitiva. </li> </ol>"},{"location":"notes/geometry/base_implementation/#operadores-de-comparacion","title":"Operadores de comparaci\u00f3n","text":"<p>Como no hay un orden natural para los puntos, vamos a s\u00f3lo diferenciar cuando son iguales o no.</p> <p> </p> <pre><code>bool operator==(pt a, pt b) {return a.x == b.x &amp;&amp; a.y == b.y;}\nbool operator!=(pt a, pt b) {return !(a == b);}\n</code></pre>"},{"location":"notes/geometry/base_implementation/#imprimir-puntos","title":"Imprimir puntos","text":"<p>Para imprimir un punto, vamos a usar definir el operador <code>&lt;&lt;</code> para que imprima <code>(x,y)</code>.</p> <p> </p> <pre><code>ostream&amp; operator&lt;&lt;(ostream&amp; os, pt p) {\nreturn os &lt;&lt; \"(\"&lt;&lt; p.x &lt;&lt; \",\" &lt;&lt; p.y &lt;&lt; \")\";\n}\n</code></pre> <p>Entonces podemos imprimir un punto de la siguiente forma:</p> <p> </p> <pre><code>pt a{3,4}, b{2,-1};\ncout &lt;&lt; a+b &lt;&lt; \" \" &lt;&lt; a-b &lt;&lt; \"\\n\"; // (5,3) (1,5)\ncout &lt;&lt; a*-1 &lt;&lt; \" \" &lt;&lt; b/2 &lt;&lt; \"\\n\"; // (-3,-4) (1.5,2)\n</code></pre>"},{"location":"notes/geometry/base_implementation/#distancia-entre-puntos","title":"Distancia entre puntos","text":"<p>Para calcular la distancia entre dos puntos, vamos a usar la f\u00f3rmula de la distancia euclidiana. Primero definimos la norma de un punto:</p> <p> </p> <pre><code>T sq(pt p) {return p.x*p.x + p.y*p.y;}\ndouble abs(pt p) {return sqrt(sq(p));}\n</code></pre> <p>Ahora podemos calcular la distancia entre dos puntos:</p> <p> </p> <pre><code>double dist(pt a, pt b) {return abs(a-b);}\n</code></pre>"},{"location":"notes/geometry/base_implementation/#conclusiones","title":"Conclusiones","text":"<p>Lo presentado en esta entrada es una breve implementaci\u00f3n de una estrucutra de puntos que nos ayudar\u00e1 a manejarlos de forma m\u00e1s fluida. En contraste a ocupar <code>pair&lt;double, double&gt;</code> y definir todas sus funciones aparte. Esta forma de trabajar nos da una estructura c\u00f3moda para llegar y usar, adem\u00e1s de expandible.</p> <p>Pueden agregarle m\u00e1s funcionalidades \u00e9chando un vistazo a los siguientes c\u00f3digos:</p> <ul> <li>Implementaci\u00f3n de Benja</li> <li>Implementaci\u00f3n de Pablo</li> </ul>"},{"location":"notes/geometry/base_implementation/#material-consultado","title":"Material consultado","text":"<ul> <li>Handbook of geometry for competitive programmers.</li> </ul>"},{"location":"notes/geometry/dot_and_cross_product/","title":"Producto punto y producto cruz","text":"<p>Lo que llamamos producto punto y producto cruz son formas de multiplicar vectores. La primera nos da como resultado un n\u00famero mientras que la segunda nos da como resultado otro vector.</p> <p>M\u00e1s que conocer sus f\u00f3rmulas de computo, lo valioso de estas yace en su significado geom\u00e9trico.</p>"},{"location":"notes/geometry/dot_and_cross_product/#producto-punto","title":"Producto punto","text":"<p>El producto punto entre el vector \\(v\\) y el vector \\(w\\) es el largo de la proyecci\u00f3n del vector \\(v\\) sobre el vector \\(w\\) multiplicado por el largo del vector \\(w\\).</p> <p>Lo importante ac\u00e1 est\u00e1 en que nos da informaci\u00f3n sobre la proyecci\u00f3n de un vector sobre el otro. Si el producto es; positivo significa que forman un \u00e1ngulo agudo, si es cero entonces son perpendiculares y por \u00faltimo si es negativo quiere decir que forman siempre un \u00e1ngulo obtuso.</p> <p></p>"},{"location":"notes/geometry/dot_and_cross_product/#formula","title":"F\u00f3rmula","text":"<p>Sea \\(v\\) y \\(w\\) vectores en \\(\\mathbb{R}^2\\) entonces el producto punto entre ellos es:</p> \\[ (x_1, y_1) \\cdot (x_2, y_2) = x_1x_2 + y_1y_2 \\]"},{"location":"notes/geometry/dot_and_cross_product/#implementacion","title":"Implementaci\u00f3n","text":"<p>Usando la vista en base implementation.</p> <p> </p> <pre><code>T dot(pt v, pt w) { return v.x*w.x + v.y*w.y; } // (1)!\n</code></pre> <ol> <li> Definir esto afuera de la struct <code>pt</code>.</li> </ol> <p>Adem\u00e1s tambi\u00e9n podemos saber si dos vectores son perpendiculares o no:</p> <p> </p> <pre><code>bool is_perp(pt v, pt w) { return dot(v, w) == 0; } // (1)!\n</code></pre> <ol> <li> Definir esto afuera de la struct <code>pt</code>.</li> </ol>"},{"location":"notes/geometry/dot_and_cross_product/#producto-cruz","title":"Producto cruz","text":"<p>El producto cruz entre el vector \\(v\\) y el vector \\(w\\) es el vector perpendicular a ambos cuyo modulo es igual al \u00e1rea del paralelogramo que generan \\(v\\) y \\(w\\).</p> <p>Al igual que en el producto anterior, lo importante no est\u00e1 en la f\u00f3rmula si no que en el signo de su resultado. Si su producto es igual a cero entonces \\(v\\) y \\(w\\) son colineales. Por otro lado, si es positivo entonces \\(v\\) a \\(w\\) est\u00e1n en sentido antihorario, si es negativo est\u00e1n en sentido horario.</p> <p></p>"},{"location":"notes/geometry/dot_and_cross_product/#formula_1","title":"F\u00f3rmula","text":"<p>Sea \\(v\\) y \\(w\\) vectores en \\(\\mathbb{R}^2\\) entonces el producto cruz entre ellos es:</p> \\[ (x_1, y_1) \\times (x_2, y_2) = x_1y_2 - y_1x_2 \\]"},{"location":"notes/geometry/dot_and_cross_product/#implementacion_1","title":"Implementaci\u00f3n","text":"<p>Usando la vista en base implementation.</p> <p> </p> <pre><code>T cross(pt v, pt w) { return v.x*w.y - v.y*w.x; } // (1)!\n</code></pre> <ol> <li> Definir esto afuera de la struct <code>pt</code>.</li> </ol> <p>Adem\u00e1s tambi\u00e9n podemos saber si dos vectores son colineales o no:</p> <p> </p> <pre><code>bool is_colinear(pt v, pt w) { return cross(v, w) == 0; } // (1)!\n</code></pre> <ol> <li> Definir esto afuera de la struct <code>pt</code>.</li> </ol>"},{"location":"notes/geometry/dot_and_cross_product/#material-consultado","title":"Material consultado","text":"<ul> <li>Handbook of geometry for competitive programmers. De aqu\u00ed se sac\u00f3 las im\u00e1genes.</li> </ul>"},{"location":"notes/math/modular_arithmetic/","title":"Aritm\u00e9tica Modular","text":""},{"location":"notes/math/modular_arithmetic/#motivacion","title":"Motivaci\u00f3n","text":"<p>Muchas veces en programaci\u00f3n competitiva nos encontramos con problemas que involucran n\u00fameros muy grandes. Para poder entregar soluciones que no sobrepasen el l\u00edmite del tipo de dato <code>int</code> o <code>long long</code> se usa aritm\u00e9tica modular. El cual acorta los n\u00fameros a un rango espec\u00edfico y mantiene un buen funcionamiento de las operaciones.</p> <p>Otro uso de aritm\u00e9tica modular es ver la divisibilidad de un n\u00famero entre otro, o si un n\u00famero es primo o no. Adem\u00e1s de su uso directo en problemas de t\u00f3pico matem\u00e1tico, puede ser de ayuda cuando haya una noci\u00f3n ciclo involucrado en el problema.</p> <p></p> <p>Imagina que tienes un reloj de 12 horas y quieres saber qu\u00e9 hora es en 5 horas m\u00e1s. Si no usas aritm\u00e9tica modular, tendr\u00edas que hacer la cuenta de \\(x + 5\\). Pero tendr\u00edas que hacer una condici\u00f3n para ver si la hora es mayor a 12 y restarle 12. Con aritm\u00e9tica modular, la hora correcta es \\(x + 5 \\mod 12\\).</p> <p>La primera soluci\u00f3n ser\u00eda hacer algo as\u00ed:</p> <pre><code>int x = 7;\nint ans = x + 5;\nif (ans &gt; 12) ans -= 12;\ncout &lt;&lt; ans &lt;&lt; '\\n';\n</code></pre> <p>En cambio, con aritm\u00e9tica modular, la soluci\u00f3n ser\u00eda:</p> <pre><code>int x = 7;\nint y = (x + 5) % 12;\ncout &lt;&lt; y; // 12\n</code></pre> <p>Los lengajes de programaci\u00f3n tienen implementaciones de aritm\u00e9tica modular con el operador <code>%</code>.</p> <p>Despu\u00e9s de esta breve introducci\u00f3n, formalicemos (no en mayor medida) la aritm\u00e9tica modular.</p>"},{"location":"notes/math/modular_arithmetic/#definicion","title":"Definici\u00f3n","text":"<p>Diremos que un n\u00famero \\(a\\) es congruente a \\(b\\) m\u00f3dulo \\(n\\) si \\(a \\equiv b \\pmod{n}\\). Esto significa que \\(a\\) y \\(b\\) son iguales cuando se mira el resto que dejan al dividirlos entre \\(n\\). Por ejemplo, \\(5 \\equiv 2 \\pmod{3}\\), ya que \\(5 = 2 \\cdot 3 + 2\\) y \\(2 = 3 \\cdot 0 + 2\\).</p> <p>En <code>C++</code>, podemos usar el operador <code>%</code> para calcular el resto de la divisi\u00f3n de dos n\u00fameros. Por ejemplo, \\(5 \\mod 3 = 2\\) se puede calcular como <code>5 % 3</code>.</p>"},{"location":"notes/math/modular_arithmetic/#propiedades","title":"Propiedades","text":"<p>Procederemos a enunciar algunas propiedades importantes al momento de operar en aritm\u00e9tica modular.</p>"},{"location":"notes/math/modular_arithmetic/#propiedad-de-la-suma-de-congruencia","title":"Propiedad de la suma de congruencia","text":"<p>Si \\(a \\equiv b \\pmod{n}\\) y \\(c \\equiv d \\pmod{n}\\), entonces \\(a + c \\equiv b + d \\pmod{n}\\).</p> <p>Esto nos es \u00fatil para separar sumas en m\u00f3dulo \\(n\\). Por ejemplo, si queremos calcular \\(2 + 3 + 4 \\mod 5\\), podemos calcular \\(2 + 3 \\mod 5\\) y luego sumarle \\(4 \\mod 5\\).</p>"},{"location":"notes/math/modular_arithmetic/#propiedad-de-la-multiplicacion-de-congruencia","title":"Propiedad de la multiplicaci\u00f3n de congruencia","text":"<p>Si \\(a \\equiv b \\pmod{n}\\) y \\(c \\equiv d \\pmod{n}\\), entonces \\(ac \\equiv bd \\pmod{n}\\).</p> <p>Esto nos es \u00fatil para separar multiplicaciones en m\u00f3dulo \\(n\\). Por ejemplo, si queremos calcular \\(2 \\cdot 3 \\cdot 4 \\mod 5\\), podemos calcular \\(2 \\cdot 3 \\mod 5\\) y luego multiplicarle \\(4 \\mod 5\\). Tambi\u00e9n podemos usar esta propiedad para calcular potencias en m\u00f3dulo \\(n\\).</p>"},{"location":"notes/math/modular_arithmetic/#propiedad-de-la-inversa-de-suma-congruencia","title":"Propiedad de la inversa de suma congruencia","text":"<p>Si \\(a \\equiv b \\pmod{n}\\), entonces \\(a - b \\equiv 0 \\pmod{n}\\).</p> <p>Esto nos da la noci\u00f3n de elemento inverso en aritm\u00e9tica modular. Que es \u00fatil al momento de hacer ecuaciones lineales en m\u00f3dulo \\(n\\).</p>"},{"location":"notes/math/modular_arithmetic/#propiedad-de-la-inversa-de-multiplicacion-congruencia","title":"Propiedad de la inversa de multiplicaci\u00f3n congruencia","text":"<p>Si \\(a \\equiv b \\pmod{n}\\) y \\(b \\neq 0\\), entonces \\(a \\cdot b^{-1} \\equiv 1 \\pmod{n}\\). Donde \\(b^{-1}\\) es el inverso de \\(b\\) en el grupo de multiplicaci\u00f3n m\u00f3dulo \\(n\\). O sea, el n\u00famero \\(b^{-1}\\) tal que \\(b \\cdot b^{-1} \\equiv 1 \\pmod{n}\\).</p>"},{"location":"notes/strings/kmp/","title":"Algoritmo de Knuth-Morris-Pratt (KMP)","text":""},{"location":"notes/strings/kmp/#introduccion","title":"Introducci\u00f3n","text":"<p>El algoritmo de KMP es un algoritmo que sirve para encontrar todas las ocurrencias de un patr\u00f3n en un string. KMP es una mejora del algoritmo de fuerza bruta. El algoritmo de fuerza bruta revisa cada posici\u00f3n del string y va comparando el patr\u00f3n con el substring del string que empieza en esa posici\u00f3n. El algoritmo de KMP es m\u00e1s eficiente porque cada vez que hay una comparaci\u00f3n fallida, se salta a la siguiente posici\u00f3n del string donde es posible que el patr\u00f3n aparezca. Se aprovecha de las comparaciones parciales. Cosa que no hace el algoritmo de fuerza bruta.</p>"},{"location":"notes/strings/kmp/#observacion-base","title":"Observaci\u00f3n base","text":"<p>KMP se basa en la siguiente observaci\u00f3n. Si tenemos un patr\u00f3n el cual tiene una comparaci\u00f3n parcial correcta de un prefijo suyo. Si este \u00faltimo posee un prefijo (\\(p\\)) y un sufijo (\\(s\\)) que son iguales (\\(p = s\\)). Entonces si se falla en el siguiente car\u00e1cter, podemos saltar a cuando inicia el sufijo y asumir que el prefijo ya fue comparado correctamente. Esto se puede ver en la siguiente ejemplo:</p> <p>Patr\u00f3n a buscar <code>ABABAC</code>, string <code>ABABABAC</code>.</p> <p>Se hace el siguiente proceso:</p> <ol> <li> <p>Se compara hasta <code>ABABA</code>, la cual es una comparaci\u00f3n parcial correcta.</p> \\[     \\colorbox{yellowgreen}{ABABA} BAC \\] </li> <li> <p>Falla en la comparaci\u00f3n del car\u00e1cter <code>C</code> con el car\u00e1cter <code>B</code>.</p> \\[     \\colorbox{yellowgreen}{ABABA} \\colorbox{red}{B} AC \\] </li> <li> <p>Como el prefijo <code>ABABA</code> tiene un sufijo <code>ABA</code> y un prefijo <code>ABA</code> que son iguales, podemos saltar a la posici\u00f3n donde inicia el sufijo y asumir que el prefijo ya fue comparado correctamente.</p> \\[     AB\\colorbox{yellowgreen}{ABA}BAC \\] </li> <li> <p>Continuamos comparando hasta que se encuentra una comparaci\u00f3n total correcta.</p> \\[     AB\\colorbox{yellowgreen}{ABABAC} \\] </li> </ol> <p>Note</p> <p><code>ABABA</code> tambi\u00e9n ten\u00eda el prefijo/sufijo <code>A</code> pero si hubi\u00e9ramos saltado a esa posici\u00f3n no habr\u00edamos encontrado el patr\u00f3n en el string. De todos modos no siempre va a convenir utilizar el prefijo/sufijo m\u00e1s largo.</p>"},{"location":"notes/strings/kmp/#implementacion","title":"Implementaci\u00f3n","text":"<p>La implementaci\u00f3n de KMP es muy similar a la de fuerza bruta. La diferencia es que vamos a dar saltos en el string cuando hay una comparaci\u00f3n parcial fallida. Pero primero debemos calcular los saltos que vamos a dar.</p>"},{"location":"notes/strings/kmp/#funcion-de-fallo","title":"Funci\u00f3n de fallo","text":"<p>Vamos a ocupar la observaci\u00f3n y calcularemos el largo del prefijo/sufijo m\u00e1s largo para cada prefijo del patr\u00f3n. Si no tiene, entonces su largo ser\u00e1 de \\(0\\).</p> <p>Sigamos con el mismo ejemplo donde el patr\u00f3n es <code>ABABAC</code>. Su arreglo de prefijos/sufijos m\u00e1s largos \\(f\\) ser\u00e1:</p> <p> Prefijo Prefijo m\u00e1s largo Largo prefijo m\u00e1s largo (\\(f(i)\\)) \"\" \"\" 0 <code>A</code> \"\" 0 <code>AB</code> \"\" 0 <code>ABA</code> <code>A</code> 1 <code>ABAB</code> <code>AB</code> 2 <code>ABABA</code> <code>ABA</code> 3 <code>ABABAC</code> \"\" 0 <p></p> <p>Donde \"\" es el string vac\u00edo.</p> <p>Llamaremos \\(f(i)\\) al largo del prefijo/sufijo m\u00e1s largo del prefijo del patr\u00f3n de largo \\(i\\).</p> <p>Notemos que \\(f(f(i))\\) es la segunda mejor coincidencia de prefijo/sufijo m\u00e1s largo. Por ejemplo, si \\(f(5) = 3\\), entonces \\(f(3) = 1\\). Que coincide con que <code>ABABA</code> tiene tanto a <code>ABA</code> como a <code>A</code> como prefijo/sufijo's. Esto se puede iterar, y obtener el tercero mejor, cuarto mejor y as\u00ed, hasta llegar a \\(f(f(\\ldots)) = 0\\).</p> <p>Esta observaci\u00f3n nos sirve para calcular \\(f(i)\\) sabiendo todos los \\(f(j)\\) con \\(j &lt; i\\). \\(f(i)\\) va a ser igual al largo del prefijo/sufijo m\u00e1s largo del prefijo de largo \\(i - 1\\) que se pueda extender con el car\u00e1cter \\(i\\)-\u00e9simo, o sea que siga siendo prefijo/sufijo del prefijo \\(i\\). Por lo que hay que comprobar con todos los prefijo/sufijo's del prefijo de largo \\(i - 1\\). Ac\u00e1 ocupamos la observaci\u00f3n iterando \\(f(i-1)\\) sobre si misma.</p>"},{"location":"notes/strings/kmp/#codigo","title":"C\u00f3digo","text":"<p>A esto se le llama funci\u00f3n de fallo y su implementaci\u00f3n en C++ es la siguiente:</p> <p> </p> <pre><code>vector&lt;int&gt; failure_function(string pattern) {\nint n = pattern.size();\nvector&lt;int&gt; f(n + 1);\nf[0] = f[1] = 0;    // (1)!\nfor (int i = 2; i &lt;= n; i++) {\nint j = f[i - 1];    // (2)!\nwhile (j &gt; 0 &amp;&amp; pattern[j] != pattern[i - 1]){    // (3)!\nj = f[j];\n}\nif (pattern[j] == pattern[i - 1]){    // (4)!\nj++;\n}\nf[i] = j;    // (5)!\n}\nreturn f;\n}\n</code></pre> <ol> <li> Inicializamos los casos base.</li> <li> Inicializamos j con el prefijo/sufijo m\u00e1s largo del prefijo de largo i - 1.</li> <li> Iteramos siempre y cuando no podamos extender el prefijo/sufijo del prefijo de largo i - 1 con el car\u00e1cter j-\u00e9simo.</li> <li> Si podemos extender el prefijo/sufijo del prefijo de largo i - 1 con el car\u00e1cter j-\u00e9simo, entonces lo extendemos.</li> <li> Guardamos el prefijo/sufijo m\u00e1s largo del prefijo de largo i.</li> </ol>"},{"location":"notes/strings/kmp/#implementacion-kmp","title":"Implementaci\u00f3n KMP","text":"<p>Ahora que tenemos la funci\u00f3n de fallo podemos implementar el algoritmo KMP.</p> <p>Como ya se mencion\u00f3 en un inicio, la idea va a ser que cada que una comparaci\u00f3n parcial falle, vamos a saltar a la posici\u00f3n donde inicia el prefijo/sufijo m\u00e1s largo del prefijo que ya fue comparado. Y continuamos con el siguiente car\u00e1cter. Si este siguiente car\u00e1cter no coincide, intentamos con el segundo mejor prefijo/sufijo. Y as\u00ed sucesivamente hasta llegar a que no hayan m\u00e1s prefijos/sufijos o que alguno calce, y continuamos con la comparaci\u00f3n parcial normal.</p>"},{"location":"notes/strings/kmp/#codigo_1","title":"C\u00f3digo","text":"<p>El c\u00f3digo de KMP en C++ es el siguiente:</p> <p> </p> <pre><code>vector&lt;int&gt; kmp(string text, string pattern) {\nvector&lt;int&gt; f = failure_function(pattern);\nvector&lt;int&gt; matches;\nint n = text.size();\nint m = pattern.size();\nint i = 0, j = 0;    // (1)!\nwhile (i &lt; n) {\nif (text[i] == pattern[j]) {    // (2)!\ni++;\nj++;\nif (j == m) {   // (3)!\nmatches.push_back(i - m);\nj = f[j];\n}\n} else if (j &gt; 0) {    // (4)!\nj = f[j];\n} else {    // (5)!\ni++;\n}\n}\nreturn matches;\n}\n</code></pre> <ol> <li> i es el \u00edndice del texto y j es el \u00edndice del patr\u00f3n.</li> <li> Si el car\u00e1cter i-\u00e9simo del texto coincide con el car\u00e1cter j-\u00e9simo del patr\u00f3n, entonces avanzamos ambos \u00edndices. </li> <li> Si j llega a ser igual al largo del patr\u00f3n, entonces encontramos una coincidencia y guardamos la posici\u00f3n donde inicia el patr\u00f3n en el texto. Luego, asignamos j al prefijo/sufijo m\u00e1s largo del prefijo de largo j.</li> <li> Si j es mayor a 0, significa que estamos buscar el prefijo/sufijo m\u00e1s largo del prefijo de largo j que coincida con la expansi\u00f3n del car\u00e1cter i-\u00e9simo del texto. Por lo que vamos por el siguiente candidato, f(j). </li> <li> Si no, entonces avanzamos i. Este es el caso de la b\u00fasqueda normal.</li> </ol>"},{"location":"notes/strings/kmp/#material-consultado","title":"Material consultado","text":"<ul> <li>Introduction to String Searching Algorithms \u2014 topcoder</li> </ul>"},{"location":"notes/strings/rolling_hashing/","title":"Rolling Hashing","text":""},{"location":"notes/strings/rolling_hashing/#introduccion","title":"Introducci\u00f3n","text":"<p>Supongamos que quieres saber si el d\u00edgito \\(0\\) esta o no dentro de un numero muy grande. Este es un cl\u00e1sico algoritmo de b\u00fasqueda secuencial donde ves d\u00edgito por d\u00edgito si es igual o no a \\(0\\). Si el largo del numero es de \\(n\\) entonces la complejidad es \\(\\mathcal{O}(n)\\).</p> <p>Modifiquemos un poco el problema y en vez de saber si un d\u00edgito est\u00e1 en el numero preguntemos si un string est\u00e1 dentro de otro. Por ejemplo, verificar si <code>abc</code> est\u00e1 en <code>abracadabra</code>. Al ocupar el mismo algoritmo de b\u00fasqueda secuencial la complejidad no ser\u00e1 de \\(\\mathcal{O}(n)\\) ya que la comparaci\u00f3n de strings se hace car\u00e1cter por car\u00e1cter. De hecho su complejidad es de \\(\\mathcal{O}(n \\cdot m)\\) donde \\(m\\) es el largo del string que estamos buscando.</p> <p>Ac\u00e1 es donde entra el algoritmo de Rolling Hashing. Este algoritmo nos va a permitir comparar dos strings en \\(\\mathcal{O}(1)\\). La intuici\u00f3n por detr\u00e1s es que vamos a transformar cada substring que queremos comparar en un d\u00edgito para que asi hacer uns b\u00fasqueda secuencial con n\u00fameros. Los cuales son comparados en \\(\\mathcal{O}(1)\\).</p> <p>Info</p> <p>Un hash es una funci\u00f3n que sirve para almacenar y recuperar datos de una manera eficiente.</p>"},{"location":"notes/strings/rolling_hashing/#hashing","title":"Hashing","text":"<p>Para calcular el hash de una cadena ocupamos polynomial hashing. La idea es que cada car\u00e1cter de la cadena se encripta en un n\u00famero. Y luego anidamos para alguna base.</p> <p>Intuici\u00f3n</p> <p>Pasar de <code>abc</code> \\(\\rightarrow\\) <code>123</code> y <code>dcbe</code> \\(\\rightarrow\\) <code>4321</code>.</p> <p>El problema es que si la cadena es muy larga, el n\u00famero podr\u00eda ser muy grande y no caber en un <code>int</code> (overflow). Para solucionar esto ocuparemos aritm\u00e9tica modular.</p> <p>Sea \\(S\\) el string que queremos encriptar, y \\(A\\) y \\(B\\) dos primos. Entonces, el hash de \\(S\\) es:</p> \\[ \\sum_{i=0}^{n-1} S[i] \\cdot A^i \\mod B \\] <p>Cada car\u00e1cter se multiplica por una potencia de \\(A\\) para minimizar la probabilidad de colisiones. El m\u00f3dulo \\(B\\) es para evitar que el n\u00famero sea muy grande y tengamos problemas de overflow. El valor de cada car\u00e1cter (\\(S[i]\\)) se puede obtener de la tabla ASCII o de alguna otra tabla que se nos ocurra.</p>"},{"location":"notes/strings/rolling_hashing/#ejemplo","title":"Ejemplo","text":"<p>Supongamos que queremos calcular el hash de la cadena <code>\"PABLO\"</code>. El valor ASCII de cada car\u00e1cter es:</p> <p> P A B L O 80 65 66 76 79 <p></p> <p>Ocupando los primos \\(A=31\\) y \\(B=10^9 + 7\\):</p> \\[ \\begin{aligned} 80 \\cdot 31^0 + 65 \\cdot 31^1 + 66 \\cdot 31^2 + 76 \\cdot 31^3 + 79 \\cdot 31^4 \\mod (10^9 + 7) = 75287796 \\end{aligned} \\] <p>En c\u00f3digo ser\u00eda:</p> <p> </p> <pre><code>int pol_hash(string s) {\nint A = 31, B = 1e9 + 7;\nint n = s.size(), h = 0;\nfor (int i = n - 1; i &gt;= 0; i--) {\nh = (h * A + s[i]) % B;\n}\nreturn h;\n}\n</code></pre>"},{"location":"notes/strings/rolling_hashing/#preprocesamiento","title":"Preprocesamiento","text":"<p>Recordemos que queremos ocupar rolling hashing para resolver problemas de b\u00fasqueda de un string en otro m\u00e1s grande. En cuyo caso no nos conviene estar calculando el hash de cada substring a comparar en cada consulta. En vez de eso, ocuparemos un arreglo de hashes, donde cada posici\u00f3n \\(i\\) del arreglo contiene el hash de la cadena desde la posici\u00f3n \\(i\\) hasta el final.</p> <p>Supongamos que \\(h\\) es dicho arreglo y que \\(i &lt; j\\). Entonces:</p> \\[ \\begin{aligned} h[i] = \\sum_{k=i}^{n-1} S[k] \\cdot A^{k-i} \\mod B \\\\ h[j] = \\sum_{k=j}^{n-1} S[k] \\cdot A^{k-j} \\mod B \\end{aligned} \\] <p>Si intentamos restar \\(h[i]\\) a \\(h[j]\\) se obtiene:</p> \\[ \\begin{aligned} h[i] - h[j] &amp;= \\sum_{k=i}^{n-1} S[k] \\cdot A^{k-i} - \\sum_{k=j}^{n-1} S[k] \\cdot A^{k-j} \\mod B \\\\ &amp;= \\left ( \\sum_{k=i}^{j-1} S[k] \\cdot A^{k-i} + \\sum_{k=j}^{n-1} S[k] \\cdot A^{k-i} \\right ) - \\sum_{k=j}^{n-1} S[k] \\cdot A^{k-j} \\mod B \\end{aligned} \\] <p>Para cancelar las dos sumatorias de la derecha hace falta multiplicar \\(h[j]\\) por \\(A^{j-i}\\). Ahora si tendremos que:</p> \\[ \\begin{aligned} h[i] - h[j] \\cdot A^{j-i} &amp;= \\sum_{k=i}^{j-1} S[k] \\cdot A^{k-i} \\mod B \\end{aligned} \\] <p>Por lo que \\(h[i] - h[j] \\cdot A^{j-i}\\) es el hash de \\(S[i \\dots j]\\) (sin contar al car\u00e1cter \\(j\\)-\u00e9simo).</p> <p>Ahora, veamos c\u00f3mo calcular \\(h[i]\\) para cada \\(i\\). Para ello podemos aprovecharnos d ela siguiente recursi\u00f3n:</p> \\[ \\begin{aligned} h[0] &amp;= S[0] \\\\ h[i] &amp;= S[i] + S[i - 1] \\cdot A \\\\ \\end{aligned} \\] <p>Adem\u00e1s de esto, ocuparemos un arreglo \\(p\\) que contiene las potencias de \\(A\\):</p> \\[ \\begin{aligned} p[0] &amp;= 1 \\\\ p[i] &amp;= p[i - 1] \\cdot A \\mod B \\\\ \\end{aligned} \\] <p>As\u00ed, el hash de un substring \\(S[i \\dots j]\\) es:</p> \\[ \\begin{aligned} h[i] - h[j + 1] \\cdot p[j - i + 1] \\mod B \\\\ \\end{aligned} \\] <p>y en el caso de que \\(i = 0\\) se reduce a \\(h[j]\\).</p>"},{"location":"notes/strings/rolling_hashing/#implementacion","title":"Implementaci\u00f3n","text":""},{"location":"notes/strings/rolling_hashing/#codigo","title":"C\u00f3digo","text":"<p>Pueden encontrar la implementaci\u00f3n de rolling hashing en el siguiente link. Esta implementaci\u00f3n es con dos \\(B\\), pero es b\u00e1sicamente la misma que se muestra a continuaci\u00f3n.</p> <p>La funci\u00f3n <code>preprocessor</code> que calcula los hashes de cada posici\u00f3n del string \\(S\\). Y la funci\u00f3n <code>get_hash</code> que calcula el hash de un substring \\(S[i \\dots j]\\):</p> <p> </p> <pre><code>const int MAXN = 1e5 + 5;\nconst int A = 31;\nconst int B = 1e9 + 7;\nint n;\nstring s;\nint h[MAXN], p[MAXN];\nvoid preprocessor() {\np[0] = 1;\nfor (int i = 1; i &lt;= n; i++) {\np[i] = (p[i - 1] * A) % B;\n}\nh[0] = s[0];\nfor (int i = n - 1; i &gt;= 0; i--) {\nh[i] = (h[i + 1] * A + s[i]) % B;\n}\n}\nint get_hash(int i, int j) {\nreturn (h[i] - h[j] * p[j - i] + B * B) % B;\n}\n</code></pre>"},{"location":"notes/strings/rolling_hashing/#uso","title":"Uso","text":"<p>Supongamos que queremos encontrar el primer substring de \\(S\\) que es igual a <code>\"PABLO\"</code>. Usando la funci\u00f3n <code>get_hash</code> podemos calcular el hash de <code>\"PABLO\"</code> y luego comparar con los hashes de cada posici\u00f3n de \\(S\\):</p> <p> </p> <pre><code>int main() {\ncin &gt;&gt; s;\nn = s.size();\npreprocessor();\nstring r = \"PABLO\";\nint m = r.size();\nint l = pol_hash(r);\nfor (int i = 0; i + m - 1 &lt; n; i++) {\nif (get_hash(i, i + m) == l) {\ncout &lt;&lt; i &lt;&lt; '\\n';\nbreak;\n}\n}\nreturn 0;\n}\n</code></pre>"},{"location":"notes/strings/rolling_hashing/#recomendaciones","title":"Recomendaciones","text":"<ul> <li>Los jueces pueden tener casos de prueba que haga que se caigan las soluciones con constantes conocidas (a.k.a. \\(10^9 + 7\\)). En ese caso, se recomienda ocupar n\u00fameros primos aleatorios, pero que est\u00e9n en el rango de \\(10^9\\).</li> </ul>"},{"location":"notes/strings/rolling_hashing/#material-consultado","title":"Material consultado","text":"<ul> <li>Competitive Programmer\u2019s Handbook \u2014 String Hashing</li> <li>ProgompCL \u2014 Rolling Hashing</li> </ul>"},{"location":"notes/strings/trie_string/","title":"Trie String","text":""},{"location":"notes/strings/trie_string/#introduccion","title":"Introducci\u00f3n","text":"<p>Trie string es una forma de guardar un conjunto de strings. La idea es almacenar los strings en un \u00e1rbol, donde cada nodo es un car\u00e1cter. De forma que si seguimos cada camino desde la ra\u00edz hasta alguna de sus hoja podamos reconstruir un string del conjunto original.</p>"},{"location":"notes/strings/trie_string/#creacion-del-arbol-con-un-ejemplo","title":"Creaci\u00f3n del \u00e1rbol con un ejemplo","text":"<p>La mejor manera de entender este algoritmo es con un ejemplo. As\u00ed que veamos c\u00f3mo hacer con los strings <code>tree</code>, <code>trie</code>, <code>algo</code>, <code>assoc</code>, <code>all</code> y <code>also</code>.</p> <p>Empezamos con el \u00e1rbol vac\u00edo solo con la ra\u00edz.</p> <p> <pre><code>graph TD\n    A[root]\n\nstyle A fill:#6b9cd5,stroke:#333</code></pre> <p></p> <p>Luego anexamos el primer string <code>tree</code> car\u00e1cter por car\u00e1cter.</p> <p> <pre><code>graph TD\n    A[root] --&gt; B((t))\n    B --&gt; C((r))\n    C --&gt; D((e))\n    D --&gt; E((e))\n    E:::leaf\n\nstyle A fill:#6b9cd5,stroke:#333\nclassDef leaf fill:#f96;</code></pre> <p></p> <p>Note</p> <p>Pintamos de naranja los nodos finales (hojas) para indicar que el string termina ah\u00ed (asi podemos distinguir strings que son prefijos de otros). Esto se ver\u00e1 en la implementaci\u00f3n.</p> <p>Veamos el siguiente string, <code>trie</code>.</p> <ol> <li>Revisamos si el nodo <code>root</code> tiene un hijo cuyo car\u00e1cter es igual a <code>t</code>.</li> <li>\u00a1Existe! se revisa si el nodo <code>t</code> tiene un hijo cuyo car\u00e1cter es igual a <code>r</code>.</li> <li>\u00a1Existe! se revisa si el nodo <code>r</code> tiene un hijo cuyo car\u00e1cter es igual a <code>i</code>.</li> <li>No existe :( a\u00f1adimos el string restante <code>ie</code> como un camino debajo del nodo <code>r</code>.</li> </ol> <p> <pre><code>graph TD\n    A[root] --&gt; B((t))\n    B --&gt; C((r))\n    C --&gt; D((e))\n    D --&gt; E((e))\n    E:::leaf\n    C --&gt; G((i))\n    G --&gt; H((e))\n    H:::leaf\n\nstyle A fill:#6b9cd5,stroke:#333\nclassDef leaf fill:#f96;</code></pre> <p></p> <p>Procedemos de forma an\u00e1loga con los dem\u00e1s strings. El \u00e1rbol quedar\u00eda de la siguiente forma:</p> <p><code>tree</code>, <code>trie</code>, <code>algo</code>, <code>assoc</code>, <code>all</code> y <code>also</code>.</p> <p> <pre><code>graph TD\n    A[root] --&gt; B((t))\n    B --&gt; C((r))\n    C --&gt; D((e))\n    D --&gt; E((e))\n    E:::leaf\n    C --&gt; G((i))\n    G --&gt; H((e))\n    H:::leaf\n    A[root] --&gt; J((a))\n    J --&gt; K((l))\n    K --&gt; L((g))\n    L --&gt; M((o))\n    M:::leaf\n    J --&gt; O((s))\n    O --&gt; P((s))\n    P --&gt; Q((o))\n    Q --&gt; R((c))\n    R:::leaf\n    J --&gt; T((l))\n    T --&gt; U((l))\n    U:::leaf\n    K --&gt; W((s))\n    W --&gt; X((o))\n    X:::leaf\n\nstyle A fill:#6b9cd5,stroke:#333\nclassDef leaf fill:#f96;</code></pre> <p></p> <p>Note</p> <p>Comprobar si un string est\u00e1 o no en el \u00e1rbol es b\u00e1sicamente el mismo proceso que para a\u00f1adirlo. Salvo que cuando no coincida un car\u00e1cter en el camino, se termina la b\u00fasqueda.</p>"},{"location":"notes/strings/trie_string/#implementacion","title":"Implementaci\u00f3n","text":"<p>Pueden encontrar la implementaci\u00f3n de trie string en el siguiente link. Con un ejemplo de uso.</p> <p>Para implementar este algoritmo necesitamos una estructura de datos que nos permita guardar el \u00e1rbol. Ocuparemos una clase <code>Trie</code> que tendr\u00e1 un nodo ra\u00edz, un m\u00e9todo <code>insert</code> para a\u00f1adir strings al \u00e1rbol y un m\u00e9todo <code>find</code> para buscar strings en el \u00e1rbol.</p> <p> </p> <pre><code>class Trie {\nstruct Node {   // (1)!\nchar c;\nbool leaf;\nvector&lt;Node*&gt; children;\nNode(char c) : c(c), leaf(false) {}\n};\nNode* root;\npublic:\nTrie() : root(new Node('\\0')) {}    // (2)!\nvoid insert(string s) {    // (3)!\nNode* cur = root;\nfor (char c : s) {\nbool found = false;\nfor (Node* child : cur-&gt;children) {\nif (child-&gt;c == c) {\ncur = child;\nfound = true;\nbreak;\n}\n}\nif (!found) {\nNode* new_node = new Node(c);\ncur-&gt;children.push_back(new_node);\ncur = new_node;\n}\n}\ncur-&gt;leaf = true;\n}\nbool find(string s) {   // (4)!\nNode* cur = root;\nfor (char c : s) {\nbool found = false;\nfor (Node* child : cur-&gt;children) {\nif (child-&gt;c == c) {\ncur = child;\nfound = true;\nbreak;\n}\n}\nif (!found) return false;\n}\nreturn cur-&gt;leaf;\n}\n};\n</code></pre> <ol> <li>La struct <code>Node</code> es una estructura que guarda un car\u00e1cter, un booleano que indica si es una hoja y un vector de punteros a nodos hijos.</li> <li>El constructor de la clase <code>Trie</code> inicializa el nodo ra\u00edz con el car\u00e1cter nulo.</li> <li>El m\u00e9todo <code>insert</code> recibe un string y lo a\u00f1ade al \u00e1rbol. Se recorre el string car\u00e1cter por car\u00e1cter y se busca si el nodo actual tiene un hijo con el car\u00e1cter actual. Si no existe, se crea un nuevo nodo con el car\u00e1cter actual y se a\u00f1ade como hijo del nodo actual. Luego se actualiza el nodo actual al nodo reci\u00e9n creado. Al final se marca el \u00faltimo nodo como hoja.</li> <li>El m\u00e9todo <code>find</code> recibe un string y busca si est\u00e1 en el \u00e1rbol. Se recorre el string car\u00e1cter por car\u00e1cter y se busca si el nodo actual tiene un hijo con el car\u00e1cter actual. Si no existe, se retorna <code>false</code>. Cuando sale del ciclo, se retorna <code>true</code> siempre y cuando el \u00faltima car\u00e1cter era una hoja. </li> </ol>"},{"location":"notes/strings/trie_string/#material-consultado","title":"Material consultado","text":"<ul> <li>Tries, Patricia Tries \u2014 Programaci\u00f3n Competitiva CL</li> <li>Trie String \u2014 GeeksForGeeks</li> </ul>"},{"location":"resources/","title":"Recursos","text":""},{"location":"resources/#para-aprender-c-ojo-novats","title":"Para aprender C++ (&lt;&lt;&lt;&lt;&lt;&lt; OJO, NOVAT@S)","text":""},{"location":"resources/#recursos-para-temas-especificos","title":"Recursos para temas espec\u00edficos","text":"<ul> <li>Backtracking</li> <li>Binary &amp; Ternary Search</li> <li>Data Structures</li> <li>Dynamic Programming (DP)</li> <li>Greedy</li> <li>Divide and Conquer</li> <li>Graphs</li> <li>Strings</li> <li>Mathematics</li> <li>Geometry</li> <li>Square Root Decomposition</li> </ul>"},{"location":"resources/#recursos-generales","title":"Recursos generales","text":"<ul> <li>Canales de Youtube con muchas explicaciones:</li> <li>Gaurav Sen</li> <li>WillianFiset</li> <li>Abdul Bari</li> <li>Algorithms Live!</li> <li>Tushar Roy - Coding Made Simple</li> <li>Agust\u00edn Santiago Guti\u00e9rrez [elsantodel90]</li> <li>Programaci\u00f3n Competitiva CL</li> <li>Repositorios con muchos c\u00f3digos de ejemplo (implementaciones de algoritmos y estructuras de datos t\u00edpicos):</li> <li>Apuntes USACO &lt;&lt;&lt;&lt;&lt;&lt;&lt; BRUTAL, ESTOS APUNTES SON DEMASIADO BUENOS</li> <li>Apuntes Benjamin Rubio (ex seleccionado PUC)</li> <li>ICPC Team Notebook. Team \"UNC - Gracias Demetrio\" &lt;&lt;&lt;&lt;&lt;&lt;&lt; MUY BUENOS TAMBI\u00c9N</li> <li>Apuntes ICPC Universidad de Chile (C++)</li> <li>https://github.com/kth-competitive-programming/kactl</li> <li>Apuntes ICPC de Robinson Castro et al (C++)</li> <li>Apuntes ICPC de Ignacio Hermosilla (C++)</li> <li>C++ Cheat Sheet for ACM ICPC</li> <li>Stanford University ICPC Team Notebook</li> <li>Repo de Apuntes del team Caloventor en Dos (C++)</li> <li>Repo de Apuntes de Pablo Messina (C++)</li> <li>Otras p\u00e1ginas con links a muchos recursos y material de estudio:</li> <li>CP-ALGORITHMS &lt;&lt;&lt;&lt;&lt;&lt; EXCELENTE P\u00c1GINA, MEGA RECOMENDADA</li> <li>Codeforces: An awesome list for competitive programming!<ul> <li>All of the good tutorials found on codeforces</li> </ul> </li> <li>Standford CS 97SI: Introduction to Programming Contests</li> <li>GeeksForGeeks: HOW TO PREPARE FOR ACM ICPC</li> <li>GeeksForGeeks: Top 10 Algorithms and Data Structures for Competitive Programming</li> <li>Sitio web del Taller de la U. de Chile</li> <li>Techie Delight: Coding made easy</li> <li>Material Campamento 2015 progcomp.cl</li> <li>Material Campamento 2016 progcomp.cl</li> <li>Material Campamento 2017 progcomp.cl</li> <li>Material Campamento 2018 progcomp.cl</li> <li>Libros con harto material de programaci\u00f3n competitiva:</li> <li>Competitive Programmer's Handbook</li> <li>Competitive Programming 2</li> <li>Competitive Programming 3 (CP3)</li> </ul>"},{"location":"resources/#soluciones-de-regionales-latinoamericanas","title":"Soluciones de Regionales Latinoamericanas","text":"<ul> <li>Blogs con explicaciones:</li> <li>Blog CaloventorEnDos</li> <li>Chocoblog</li> <li>Codeforces - ACM ICPC 2011 Latin America Finals</li> <li>Codeforces - ACM ICPC 2012 Latin America Finals</li> <li>Codeforces - ACM ICPC 2014 Latin America Finals</li> <li>Codeforces - ACM ICPC 2015 Latin America Finals</li> <li>Codeforces - ACM ICPC 2016 Latin America Finals</li> <li>Codeforces - ACM ICPC 2017 Latin America Finals</li> <li>Codeforces - ACM ICPC 2018 Latin America Finals</li> <li>Codeforces - ACM ICPC 2019 Latin America Finals</li> <li>Codeforces - ACM ICPC 2020 Latin America Finals</li> <li>Explicaciones de problemas 2020: Discuss\u00e3o dos problemas da Final</li> <li>Google Sheet con soluciones de las \u00faltimas regionales (WIP)</li> </ul>"},{"location":"resources/#soluciones-inputs-y-outputs-oficiales-de-regionales","title":"Soluciones, Inputs y Outputs oficiales de Regionales","text":"<ul> <li>Latinoam\u00e9rica:</li> <li>http://maratona.ime.usp.br/</li> <li>Norteam\u00e9rica:</li> <li>http://acmgnyr.org</li> <li>http://cs.ecs.baylor.edu/~hamerly/icpc/</li> <li>http://www.acmicpc-pacnw.org/results.htm</li> <li>http://icpc-ecna.ysu.edu/PastResults/</li> </ul>"},{"location":"resources/backtracking/","title":"Backtracking","text":"<ul> <li>https://progcomp.cl/backtracking</li> <li>6 Introduction to Backtracking - Brute Force Approach: https://www.youtube.com/watch?v=DKCbsiDBN6c</li> <li>6.1 N Queens Problem using Backtracking: https://www.youtube.com/watch?v=xFv_Hl4B83A</li> <li>6.2 Sum Of Subsets Problem - Backtracking: https://www.youtube.com/watch?v=kyLxTdsT8ws</li> <li>6.3 Graph Coloring Problem - Backtracking: https://www.youtube.com/watch?v=052VkKhIaQ4</li> <li>Algor\u00edtmia - Tema 5. Backtracking. N-Reinas - Andr\u00e9s Mu\u00f1oz Ortega: https://www.youtube.com/watch?v=XQYGwKiqV3Y</li> </ul>"},{"location":"resources/data_structures/","title":"Estructuras de Datos","text":""},{"location":"resources/data_structures/#c-stl-data-structures-para-llegar-y-usar","title":"C++ STL Data Structures (para llegar y usar)","text":"<ul> <li>Utils:</li> <li>pairs &amp; tuples: video, doc pairs, doc tuples, geeksforgeeks, c\u00f3digo</li> <li> <p>iterators: video, docu, geeksforgeeks 1, geeksforgeeks 2, c\u00f3digo</p> </li> <li> <p>Sequence Containers:</p> </li> <li>youtube: Introduction of STL #2: Sequence Containers (el video cubre vector, deque, list, forward list, array)</li> <li>youtube: C++ STL Part - 7 : The Container Adapters - Stack, Queue &amp; Priority Queue (el video cubre stack, queue y priority_queue)</li> <li>arrays: documentaci\u00f3n, c\u00f3digo</li> <li>vector: documentaci\u00f3n, geeksforgeeks, c\u00f3digo</li> <li>deque: documentaci\u00f3n, geeksforgeeks, c\u00f3digo</li> <li>queue: documentaci\u00f3n, geeksforgeeks, c\u00f3digo</li> <li>stack: documentaci\u00f3n, geeksforgeeks, c\u00f3digo</li> <li>priority_queue (minheap / maxheap): documentaci\u00f3n, geeksforgeeks, c\u00f3digo</li> <li> <p>list (lista doblemente ligada): documentaci\u00f3n, geeksforgeeks, c\u00f3digo</p> </li> <li> <p>Associative Containers:</p> </li> <li>youtube: Introduction of STL #3: Associative Containers (el video cubre set, multiset, map, multimap)</li> <li>Set: documentaci\u00f3n, geeksforgeeks, c\u00f3digo</li> <li>Multiset: documentaci\u00f3n, geeksforgeeks, c\u00f3digo</li> <li>Map: documentaci\u00f3n, geeksforgeeks, c\u00f3digo</li> <li> <p>Multimap: documentaci\u00f3n, geeksforgeeks, c\u00f3digo</p> </li> <li> <p>Unordered Containers:</p> </li> <li>Introduction of STL #4: Unordered Containers (el video cubre unordered set/multiset/map/multimap)</li> <li>unordered_set: documentaci\u00f3n, geeksforgeeks, c\u00f3digo</li> <li>unordered_multiset: documentaci\u00f3n, geeksforgeeks, c\u00f3digo</li> <li>unordered_map: documentaci\u00f3n, geeksforgeeks, c\u00f3digo</li> <li> <p>unordered_multimap: documentaci\u00f3n, geeksforgeeks, c\u00f3digo</p> </li> <li> <p>Policy based data structures:</p> </li> <li>codeforces: C++ STL: Policy based data structures</li> <li>geeksforgeeks: Policy based data structures in g++</li> <li>orderered_set: geeksforgeeks, c\u00f3digo</li> </ul>"},{"location":"resources/data_structures/#repos-con-implementaciones-de-estructuras-de-datos","title":"Repos con implementaciones de estructuras de datos","text":"<ul> <li>Apuntes de Benja</li> <li>Apuntes de Pablo</li> </ul>"},{"location":"resources/data_structures/#sparse-table","title":"Sparse Table","text":"<ul> <li>(youtube)Sparse Table Algorithm Range Minimum Query</li> <li>(youtube)Sparse Table Tutorial / RMQ</li> <li>cp-algorithms: sparse table</li> <li>C\u00f3digo 1, C\u00f3digo 2</li> </ul>"},{"location":"resources/data_structures/#segment-tree","title":"Segment Tree","text":"<ul> <li>cp-algorithms: segment tree</li> <li>http://progcomp.cl/segmenttree</li> <li>(youtube) Segment Tree Range Minimum Query</li> <li>(youtube) Segment Tree [ICPCCL 2016]</li> <li>(codeforces) Efficient and easy segment trees (c\u00f3mo hacer segment trees iterativos)</li> <li>C\u00f3digo 1, C\u00f3digo 2</li> </ul>"},{"location":"resources/data_structures/#segment-tree-lazy","title":"Segment Tree Lazy","text":"<ul> <li>cp-algorithms: segment tree lazy</li> <li>youtube: Lazy Propagation Segment Tree</li> <li>youtube: Segment Tree - Range Queries with Lazy Updates</li> <li>C\u00f3digo 1, C\u00f3digo 2</li> </ul>"},{"location":"resources/data_structures/#fenwick-tree-aka-bit-o-binary-indexed-tree","title":"Fenwick Tree (a.k.a. BIT o Binary Indexed Tree)","text":"<ul> <li>(youtube) Tutorial: Binary Indexed Tree (Fenwick Tree)</li> <li>(youtube) Fenwick Tree explicado por Jorge P\u00e9rez</li> <li>https://youtu.be/0PzR0IoqkkU?t=1453 (por si quieren ver la explicaci\u00f3n de sweep line tambi\u00e9n que viene justo antes)</li> <li>(youtube) youtube: Fenwick Tree or Binary Indexed Tree</li> <li>cp-algorithms: fenwick tree</li> <li>HackerEarth - binary indexed tree made easy</li> <li>http://progcomp.cl/fenwicktree</li> <li>cs.stackexchange: BIT: What is the intuition behind a binary indexed tree and how was it thought about?</li> <li>Topcoder: binary indexed trees</li> <li>Fenwick Tree 2D:</li> <li>geeksforgeeks - Two Dimensional Binary Indexed Tree or Fenwick Tree</li> <li>youtube: explicaci\u00f3n de Jorge P\u00e9rez</li> <li>Topcoder: BIT 2D</li> <li>C\u00f3digos de ejemplo:</li> <li>Fenwick tree 1D: C\u00f3digo 1, C\u00f3digo 2</li> <li>Fenwick tree 2D: C\u00f3digo 1, C\u00f3digo 2</li> </ul>"},{"location":"resources/data_structures/#union-find-aka-dsu-o-disjoint-set-union","title":"Union Find (a.k.a. DSU o Disjoint Set Union)","text":"<ul> <li>cp-algorithms: Disjoint Set Union</li> <li>(youtube) 1.12 Disjoint Sets Data Structure - Weighted Union and Collapsing Find</li> <li>(youtube) Disjoint Sets using union by rank and path compression Graph Algorithm</li> <li>(youtube) Union Find Path Compression</li> <li>geeksforgeeks: Disjoint Set (Or Union-Find) | Set 1 (Detect Cycle in an Undirected Graph)</li> <li>geeksforgeeks: Union-Find Algorithm | Set 2 (Union By Rank and Path Compression)</li> <li>C\u00f3digo de ejemplo</li> </ul>"},{"location":"resources/data_structures/#treap","title":"Treap","text":"<ul> <li>https://cp-algorithms.com/data_structures/treap.html</li> </ul>"},{"location":"resources/data_structures/#wavelet-tree","title":"Wavelet Tree","text":"<ul> <li>https://www.dcc.uchile.cl/~jperez/papers/ioiconf16.pdf</li> <li>C\u00f3digo de ejemplo</li> </ul>"},{"location":"resources/divconq/","title":"Divide and Conquer","text":"<ul> <li>(Youtube) 2 Divide And Conquer</li> <li>(Youtube) Divide and Conquer Generic Method</li> <li>https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm</li> <li>Ejemplos de aplicaciones:</li> <li>(Youtube) Merge sort in 3 minutes</li> <li>(Youtube) 2.7.2. Merge Sort Algorithm</li> <li>(Youtube) 2.8.1 QuickSort Algorithm</li> <li>(Youtube) Closest pair of points</li> <li>(Youtube) Finding the Closest Pair of Points on the Plane: Divide and Conquer</li> </ul>"},{"location":"resources/dp/","title":"Programaci\u00f3n Din\u00e1mica (DP)","text":""},{"location":"resources/dp/#que-es-dp","title":"\u00bfQu\u00e9 es DP?","text":"<ul> <li>What Is Dynamic Programming and How To Use It \\&lt;\\&lt;\\&lt;\\&lt;\\&lt; MUY BUEN VIDEO, V\u00c9ANLO!</li> <li>Principle of Optimality - Dynamic Programming introduction </li> <li>Algorithms: Memoization and Dynamic Programming</li> <li>19. Dynamic Programming I: Fibonacci, Shortest Paths</li> <li>Dos formas generales de usar DP: Bottom-Up vs Top-Down:</li> <li>http://stackoverflow.com/questions/6164629/dynamic-programming-and-memoization-bottom-up-vs-top-down-approaches</li> </ul>"},{"location":"resources/dp/#ejemplos-de-aplicaciones-de-dp","title":"Ejemplos de aplicaciones de DP","text":"<ul> <li>Coin Change: video</li> <li>Matrix Chain Multiplication: video1, video2</li> <li>Longest Increasing Subsequence (LIS): video, explicaci\u00f3n stackoverflow, c\u00f3digo ejemplo</li> <li>Knapsack problem: video</li> <li>Traveling Salesman Problem (TSP): video, implementaci\u00f3n usando bitmasks, c\u00f3digo ejemplo</li> <li>Minimum Edit Distance Between 2 Strings - The Levenshtein Distance: video1, video2</li> <li>Otros ejemplos: playlist</li> </ul>"},{"location":"resources/dp/#dp-avanzado","title":"DP Avanzado","text":"<ul> <li>Clase Optimizaciones de DP: https://youtu.be/wLSfdicxVLs</li> <li>Lista de Optimizaciones de DP: https://codeforces.com/blog/entry/8219</li> <li>Problemas para practicar Optimizaciones de DP: https://codeforces.com/blog/entry/47932</li> <li>Divide &amp; Conquer Optimization:</li> <li>https://jeffreyxiao.me/blog/divide-and-conquer-optimization</li> <li>(cp-algorithms) Divide and Conquer DP</li> <li>HackerRank: editorial explicando la t\u00e9cnica</li> <li>(youtube) Dynamic Programming Optimization: Divide and Conquer technique</li> <li>c\u00f3digo de ejemplo</li> <li>Convex Hull Trick:</li> <li>Codeforces: [Tutorial] Convex Hull Trick \u2014 Geometry being useful</li> <li>https://jeffreyxiao.me/blog/convex-hull-trick</li> <li>Knuth's Optimization:</li> <li>https://jeffreyxiao.me/blog/knuths-optimization</li> </ul>"},{"location":"resources/geometry/","title":"Geometr\u00eda","text":""},{"location":"resources/geometry/#apuntes-genericos-de-geometria","title":"Apuntes gen\u00e9ricos de geometr\u00eda","text":"<ul> <li>https://vlecomte.github.io/cp-geo.pdf (buen\u00edsimo y muy completo)</li> </ul>"},{"location":"resources/geometry/#producto-punto","title":"Producto Punto","text":"<ul> <li>Youtube: Dot products and duality | Chapter 9, Essence of linear algebra</li> <li>CodeForces: Geometry: 2D points and lines [Tutorial] (saltarse a la parte dot product)</li> <li>Youtube: Dot Product &amp; Angle Between Vectors</li> <li>Youtube: Cross Product and Dot Product: Visual explanation</li> </ul>"},{"location":"resources/geometry/#producto-cruz","title":"Producto Cruz","text":"<ul> <li>Youtube: Cross products - Essence of linear algebra, Chapter 10](https://www.youtube.com/watch?v=eu6i7WJeinw)</li> <li>Math is fun: Vector Cross Product</li> <li>StackOverlfow: Calculating a 2D Vector's Cross Product</li> <li>CodeForces: Geometry: 2D points and lines [Tutorial]</li> <li>Youtube: Cross Product and Dot Product: Visual explanation</li> </ul>"},{"location":"resources/geometry/#apuntes-varios-de-geometria-2d","title":"Apuntes varios de Geometr\u00eda 2D","text":"<ul> <li>apuntes de Benja</li> <li>apuntes de Pablo</li> <li>Video Repaso de Geometr\u00eda (muy bueno): youtube: Geometr\u00eda Computacional [ICPCCL 2016]</li> <li>CP-Algorithms: Geometry</li> </ul>"},{"location":"resources/geometry/#apuntes-varios-de-geometria-3d","title":"Apuntes varios de Geometr\u00eda 3D","text":"<ul> <li>apuntes de Benja</li> <li>apuntes de Pablo</li> </ul>"},{"location":"resources/geometry/#trigonometria","title":"Trigonometr\u00eda","text":"<ul> <li>implementaciones varias de trigonometr\u00eda</li> </ul>"},{"location":"resources/geometry/#algoritmos-varios-de-poligonos","title":"Algoritmos varios de Pol\u00edgonos","text":"<ul> <li>implementaciones varias de algoritmos sobre pol\u00edgonos</li> <li>Detectar si un punto est\u00e1 dentro de un pol\u00edgono:</li> <li>geomalgorithms: Inclusion of a Point in a Polygon</li> <li>wikipedia: Point in polygon</li> <li>Puntos extremos en un pol\u00edgono convexo:</li> <li>geomalgorithms: Extreme Points of Convex Polygons</li> <li>Pick's Theorem:</li> <li>https://cp-algorithms.com/geometry/picks-theorem.html</li> <li>https://cp-algorithms.com/geometry/lattice-points.html</li> </ul>"},{"location":"resources/geometry/#convex-hull","title":"Convex Hull","text":"<ul> <li>Buen video explicando Convex Hull: youtube: 5 6 Convex Hull 1350</li> <li>Monotone Chain Algorithm (algoritmo recomendado):</li> <li>https://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain</li> <li>C\u00f3digo de ejemplo</li> <li>Convex Hull Trick:</li> <li>https://wcipeg.com/wiki/Convex_hull_trick</li> <li>https://stackoverflow.com/questions/17834699/what-is-convex-hull-trick-exactly</li> </ul>"},{"location":"resources/geometry/#calculo-de-areas","title":"C\u00e1lculo de \u00c1reas","text":"<ul> <li>Teorema de Green (aplicado al caso particular de calcular \u00e1reas):</li> <li>lecturas:<ul> <li>https://math.stackexchange.com/questions/199003/proving-greens-theorem-for-computing-area</li> <li>https://mathinsight.org/greens_theorem_find_area</li> </ul> </li> <li>videos:<ul> <li>youtube: Green's Theorem</li> <li>youtube: 78 - Finding area with Green's theorem</li> <li>How to Use Green's Theorem to Find the Area of A Region</li> <li>Green's Theorem: area under an arch - MIT 18.02SC Multivariable Calculus, Fall 2010</li> </ul> </li> <li>C\u00f3digos de ejemplo</li> <li>Aplicaci\u00f3n a pol\u00edgonos - \u00e1rea de un pol\u00edgono simple:</li> <li>http://math.blogoverflow.com/2014/06/04/greens-theorem-and-area-of-polygons/</li> <li>http://stackoverflow.com/questions/451426/how-do-i-calculate-the-area-of-a-2d-polygon</li> <li>c\u00f3digo de ejemplo (ctrl+f \"area\")</li> </ul>"},{"location":"resources/geometry/#sweep-line-y-radial-sweep-line","title":"Sweep Line y Radial Sweep Line","text":"<ul> <li>codeforces: How to sweep like a Sir</li> <li>wikipedia: Sweep line algorithm</li> <li>topcoder: line sweep algorithms </li> </ul>"},{"location":"resources/geometry/#dualidad-linea-punto","title":"Dualidad L\u00ednea - Punto","text":"<ul> <li>Buenas slides explicando dualidad: https://algo.kaust.edu.sa/Documents/cs372l13.pdf</li> <li>Excelente pdf con demostraciones: https://pdfs.semanticscholar.org/810c/e0c19283481567c6545bf8c0cc8a4dcb8a1f.pdf</li> <li>Aplicaci\u00f3n interactiva: http://students.cec.wustl.edu/~tdeck/duality/</li> </ul>"},{"location":"resources/graphs/","title":"Grafos","text":""},{"location":"resources/graphs/#introduccion-a-grafos","title":"Introducci\u00f3n a Grafos","text":"<ul> <li>Slides de Nico Lehmann sobre Grafos (muy buenas):</li> <li>http://campamento2015.progcomp.cl/material (revisar la parte Grafos)</li> <li>http://campamento2016.progcomp.cl/material (revisar la parte Grafos)</li> <li>(youtube) Data structures: Introduction to graphs</li> <li>(youtube) Data structures: Properties of Graphs</li> <li>(youtube) Graph Representation part 01 - Edge List</li> <li>(youtube) Graph Representation part 02 - Adjacency Matrix</li> <li>(youtube) Graph Representation part 03 - Adjacency List</li> <li>(youtube) Graph Theory: 02. Definition of a Graph</li> <li>(youtube) Graph Theory: 03. Examples of Graphs</li> <li>(youtube) Graph Theory: 04. Families of Graphs</li> <li>(youtube) Graph Theory: 36. Definition of a Tree</li> <li>Grafo dirigido vs Grafo no-dirigido:</li> <li>(youtube) Graph Types Directed and Undirected Graph</li> <li>(geeksforgeeks) Graph and its representations</li> </ul>"},{"location":"resources/graphs/#algoritmos-de-graph-traversal","title":"Algoritmos de Graph Traversal","text":"<ul> <li>Breadth First Search (BFS):</li> <li>cp-algorithms: BFS</li> <li>c\u00f3digo de ejemplo</li> <li>Depth First Search (DFS):</li> <li>cp-algorithms: DFS</li> <li> <p>c\u00f3digo de ejemplo</p> </li> <li> <p>(youtube) 5.1 Graph Traversals - BFS &amp; DFS -Breadth First Search and Depth First Search</p> </li> <li>(youtube) Graph Traversals - Breadth First and Depth First</li> <li>(youtube) Graph : BFS, DFS</li> <li>(youtube) Algorithms: Graph Search, DFS and BFS</li> <li>Flood Fill: https://en.wikipedia.org/wiki/Flood_fill</li> </ul>"},{"location":"resources/graphs/#diametro-de-un-arbol","title":"Di\u00e1metro de un \u00c1rbol","text":"<ul> <li>cs.stackexchange: Algorithm to find diameter of a tree using BFS/DFS. Why does it work?</li> <li>c\u00f3digo de ejemplo</li> </ul>"},{"location":"resources/graphs/#topological-sort","title":"Topological Sort","text":"<ul> <li>(youtube) Topological Sort Algorithm | Graph Theory</li> <li>(youtube) Topological Sort Graph Algorithm</li> <li>Codeforces - How to check cycles inside a Topological Sort</li> <li>C\u00f3digos de ejemplo</li> </ul>"},{"location":"resources/graphs/#algoritmos-de-camino-mas-corto-shortest-path","title":"Algoritmos de Camino M\u00e1s Corto (Shortest Path)","text":"<ul> <li>De un nodo (single source) a todos los dem\u00e1s nodos:</li> <li> </li> <li> </li> <li>De todos los nodos (multiple source) a todos los nodos:</li> <li> </li> </ul>"},{"location":"resources/graphs/#dijkstra-cuando-no-hay-aristas-negativas","title":"Dijkstra (cuando NO hay aristas negativas)","text":"<ul> <li>(youtube) Dijkstra's algorithm in 3 minutes \u2014 Review and example</li> <li>(youtube) Dijkstra's Algorithm (5 minutos)</li> <li>(youtube) Muy buen ejemplo de Dijkstra</li> <li>(youtube) Correctness of Dijkstra's Algorithm</li> <li>cp-algorithms: dijkstra (incluye c\u00f3digo de ejemplo)</li> <li>C\u00f3digo de ejemplo</li> <li>C\u00f3digo de ejemplo Ignacio</li> </ul>"},{"location":"resources/graphs/#bellman-ford-cuando-si-hay-aristas-negativas","title":"Bellman-Ford (cuando S\u00cd hay aristas negativas)","text":"<ul> <li>(youtube) Bellman-Ford in 5 minutes \u2014 Step by step example</li> <li>(youtube) Bellman-Ford in 4 minutes \u2014 Theory</li> <li>(youtube) Bellman Ford Algorithm | Shortest path &amp; Negative cycles | Graph Theory</li> <li>(video) Bellman-Ford Algorithm: Proof of Correctness</li> <li>(youtube) Bellman Ford Algorithm - Single Source Shortest Path - Dynamic Programming (17m)</li> <li>cp-algorithms: bellman-ford (incluye c\u00f3digos de ejemplo)</li> <li>C\u00f3digo de ejemplo</li> <li>\u00bfC\u00f3mo detectar un ciclo negativo con Bellman-Ford?</li> <li>GeeksforGeeks - Detect a negative cycle in a Graph | (Bellman Ford)</li> <li>(PDF) Proof of Correctness</li> </ul>"},{"location":"resources/graphs/#floyd-warshall","title":"Floyd-Warshall","text":"<ul> <li>(youtube) Floyd\u2013Warshall algorithm in 4 minutes</li> <li>(youtube) All Pairs Shortest Path (Floyd-Warshall) - Dynamic Programming (14m)</li> <li>cp-algorithms: floyd-warshall (incluye c\u00f3digo de ejemplo)</li> <li>C\u00f3digo de ejemplo</li> <li>\u00bfQu\u00e9 pasa cuando hay ciclos negativos?</li> <li>(wikipedia) Behavior_with_negative_cycles</li> <li>Floyd-Warshall with negative cycles. How do I find all undefined paths?</li> </ul>"},{"location":"resources/graphs/#minimum-spanning-tree-mst","title":"Minimum Spanning Tree (MST)","text":"<ul> <li>(youtube) 3.5 Prims and Kruskals Algorithms - Greedy Method</li> <li>Kruskal's Algorithm:</li> <li>(youtube) Kruskal's algorithm in 2 minutes \u2014 Review and example</li> <li>(youtube) Kruskal's algorithm Minimum Spanning Tree Graph Algorithm</li> <li>Prim's Algorithm:</li> <li>(youtube) Prim's algorithm in 2 minutes \u2014 Review and example</li> <li>(youtube) Prim's Algorithm Minimum Spanning Tree Graph Algorithm</li> <li>Correcteness Proofs:</li> <li>(youtube) Proof of Cut Property</li> <li>(youtube) Proof of Prim's MST algorithm using cut property</li> <li>(youtube) Correctness of Kruskal's Algorithm</li> <li>cp-algorithms:</li> <li>Minimum Spanning Tree - Prim's Algorithm</li> <li>Minimum Spanning Tree - Kruskal</li> <li>Minimum Spanning Tree - Kruskal with Disjoint Set Union</li> <li>Second best Minimum Spanning Tree - Using Kruskal and Lowest Common Ancestor</li> <li>C\u00f3digos de ejemplo</li> </ul>"},{"location":"resources/graphs/#lowest-common-ancestor-lca","title":"Lowest Common Ancestor (LCA)","text":"<ul> <li>General Overview of Methods:</li> <li>http://codeforces.com/blog/entry/16221 (skip to the LCA part)</li> <li>M\u00e9todo 1 (RECOMENDADO): Binary Lifting Method (aka jump pointers):</li> <li>Codeforces: Lowest common ancestor's binary lifting method for path queries on trees Nota: como dice el post, este m\u00e9todo es muy \u00fatil ya que se puede adaptar para computar consultas sobre caminos entre 2 nodos en un \u00e1rbol.</li> <li>(youtube) Episode 17 - Binary Lifting</li> <li>M\u00e9todo 2: Euler Tour + Range Minimun Query:</li> <li>Topcoder: range minimum query and lowest common ancestor</li> <li>(youtube) Episode 28 - Sparse Tables and LCA</li> <li>(youtube) Sparse Table Algorithm Range Minimum Query</li> <li> <p>C\u00f3digos de ejemplo (ambos m\u00e9todos)</p> </li> <li> <p>Level Ancestor:</p> </li> <li>https://en.wikipedia.org/wiki/Level_ancestor_problem</li> <li>https://www.quora.com/Why-does-storing-log-N-pointers-work-in-the-jump-pointer-solution-of-the-level-ancestor-problem</li> <li>C\u00f3digo de ejemplo</li> </ul>"},{"location":"resources/graphs/#puntos-de-articulacion-aristas-de-corte-y-componentes-biconexas","title":"Puntos de articulaci\u00f3n, Aristas de corte y Componentes Biconexas","text":"<ul> <li>(youtube) Graph Theory: 53. Cut-Vertices</li> <li>(youtube) Graph Theory: 55. Bridges and Blocks</li> <li>HackerEarth: Articulation Points and Bridges</li> <li>HackerEarth: Biconnected Components</li> <li>(PDF) MTL776 Graph algorithms: Cut vertices, Cut Edges and Biconnected components</li> <li>(youtube) 5.2 Articulation Point and Biconnected Components</li> <li>(youtube) Articulation Points Graph Algorithm</li> <li>C\u00f3digo de ejemplo</li> <li>Teoremas relevantes:</li> <li>Menger's Theorem<ul> <li>https://en.wikipedia.org/wiki/Menger%27s_theorem</li> <li>(youtube) Menger's Theorem</li> <li>https://www.quora.com/How-can-I-prove-without-using-Mengers-theorem-that-any-two-vertices-of-a-2-connected-graph-lie-on-a-common-cycle</li> </ul> </li> </ul>"},{"location":"resources/graphs/#strongly-connected-components-scc","title":"Strongly Connected Components (SCC)","text":"<ul> <li>M\u00e9todo 1: Tarjan's Algorithm for SCC</li> <li>(youtube) Tarjans Strongly Connected Components algorithm | Graph Theory</li> <li>(geeksforgeeks) Tarjan\u2019s Algorithm to find Strongly Connected Components</li> <li>M\u00e9todo 2: Kosaraju's Algorithm for SCC</li> <li>(youtube) Strongly Connected Components Kosaraju's Algorithm Graph Algorithm</li> <li>(geeksforgeeks) Kosaraju's Algorithm to find Strongly Connected Components</li> <li>(cp-algorithms) Finding strongly connected components, Building condensation graph</li> <li>(quora) Diferencias entre Tarjan y Kosaraju</li> <li>C\u00f3digos de ejemplo</li> </ul>"},{"location":"resources/graphs/#flujo-maximo-y-aplicaciones","title":"Flujo M\u00e1ximo y aplicaciones","text":"<ul> <li>(youtube) Episode 33 - Maximum Flow Intuition</li> <li>Cu\u00e1ndo se usa:</li> <li>(MUY RECOMENDADO) (youtube) Ejemplos de problemas usando flujo</li> <li>geeksforgeeks: Maximum Bipartite Matching</li> <li>Ford-Fulkerson Algorithm:</li> <li>(youtube) Ford-Fulkerson in 5 minutes \u2014 Step by step example</li> <li>(youtube) Residual Networks - Georgia Tech - Computability, Complexity, Theory: Algorithms</li> <li>(youtube) Edmonds Karp Algorithm to find the Max Flow</li> <li>(youtube) Ford Fulkerson Algorithm Edmonds Karp Algorithm For Max Flow</li> <li>Intuici\u00f3n detr\u00e1s del grafo residual: cs.stackexchnge: Residual Graph in Maximum Flow </li> <li>Dinic Algorithm (RECOMENDADO):</li> <li>(youtube) CS261 Lecture 2 (Edmonds-Karp/Dinic algorithms)</li> <li>(PDF) CMU, 15-451 Algorithms, Fall 2014: Lecture 11: Dinic\u2019s Algorithm</li> <li>(PDF) Stanford, CS261: A Second Course in Algorithms, Lecture #2: Augmenting Path Algorithms for Maximum Flow</li> <li>C\u00f3digo de ejemplo</li> </ul>"},{"location":"resources/graphs/#heavy-light-decomposition","title":"Heavy-Light Decomposition","text":"<ul> <li>https://cp-algorithms.com/graph/hld.html</li> <li>https://blog.anudeep2011.com/heavy-light-decomposition/</li> <li>https://www.geeksforgeeks.org/heavy-light-decomposition-set-1-introduction/</li> <li>http://codeforces.com/blog/entry/22072</li> </ul>"},{"location":"resources/greedy/","title":"Greedy","text":"<ul> <li>(Youtube) Introduction to Greedy Algorithms - GeeksforGeeks</li> <li>(Youtube) Introduction to Greedy Method</li> <li>(Youtube) 3. Greedy Method - Introduction</li> <li>(Youtube) Greedy Algorithms Tutorials - GeeksforGeeks</li> </ul>"},{"location":"resources/math/","title":"Matem\u00e1ticas","text":""},{"location":"resources/math/#numeros-primos","title":"N\u00fameros Primos","text":"<ul> <li>\u00bfQu\u00e9 es un n\u00famero primo?</li> <li>What's a Prime Number?</li> <li>Wikipedia - Prime Number</li> <li>Teorema fundamental de la aritm\u00e9tica: todo natural tiene una \u00fanica factorizaci\u00f3n prima</li> <li>wikipedia - Fundamenetal theorem of arithmetic</li> <li>The Fundamental Theorem of Arithmetic</li> <li>Number Theory - Fundamental Theorem of Arithmetic</li> <li>Tests de Primalidad (c\u00f3mo saber si un n\u00famero es primo):</li> <li>CP-Algorithms: Primality tests</li> <li>stackoverflow - Fastest algorithm for primality test</li> <li>Miller Rabin:<ul> <li>cp-algorithms: Miller Rabin</li> <li>https://www.geeksforgeeks.org/primality-test-set-3-miller-rabin/</li> <li>deterministic variant: https://miller-rabin.appspot.com/</li> </ul> </li> <li>C\u00f3digos de ejemplo</li> <li>Criba de Erat\u00f3stenes (todos los primos hasta N):</li> <li>wikipedia: Sieve of Eratosthenes (hay un GIF muy bueno)</li> <li>(youtube) Finding Prime numbers - Sieve of Eratosthenes</li> <li>(youtube) Criba de Erat\u00f3stenes [ICPCCL 2016]</li> <li>C\u00f3digo de ejemplo</li> <li>Criba de Erat\u00f3stenes Segmentada (m\u00e1s r\u00e1pida):</li> <li>https://github.com/kimwalisch/primesieve/wiki/Segmented-sieve-of-Eratosthenes</li> <li>(cp-algorithms) Segmented sieve of eratosthenes</li> <li>(geeksforgeeks) Segmented Sieve (Print Primes in a Range)</li> <li>Factorizaci\u00f3n Prima de N\u00fameros Enteros:</li> <li>cp-algorithms: Integer factorization</li> <li>c\u00f3digo de ejemplo</li> <li>Factorizaci\u00f3n Prima de Factoriales:</li> <li>http://mathforum.org/library/drmath/view/67291.html</li> <li>https://janmr.com/blog/2010/10/prime-factors-of-factorial-numbers/</li> <li>https://forthright48.com/prime-factorization-of-factorial/</li> <li>c\u00f3digo de ejemplo</li> </ul>"},{"location":"resources/math/#aritmetica-modular","title":"Aritm\u00e9tica Modular","text":"<ul> <li>\u00bfDe qu\u00e9 se trata Aritm\u00e9tica Modular?</li> <li>Art of Problem Solving: Modular Arithmetic / Introduction</li> <li>(wikipedia) Modular Arithmetic</li> <li>(youtube) Introduction to Modular arithmetic</li> <li>(youtube) High level introduction to modular arithmetic</li> <li>(youtube) Congruence (Modular Arithmetic) &amp; 5 Properties Explained with 7 Problems: Ultimate Shortcuts</li> <li> <p>(wikipedia) Identidades en Aritm\u00e9tica Modular</p> </li> <li> <p>Modular Inverse:</p> </li> <li>cp-algorithms - Modular Inverse</li> <li>Youtube - Multiplicative inverses mod n</li> <li>Modular Exponentiation By Squaring:</li> <li>https://en.wikipedia.org/wiki/Modular_exponentiation#Right-to-left_binary_method</li> <li>https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Mathematics/binary_modular_exponentiation.cpp</li> <li>Modular Fibonacci with Exponentiation by Squaring:</li> <li>http://mathoverflow.net/questions/40816/fibonacci-series-mod-a-number</li> </ul>"},{"location":"resources/math/#binary-exponentiation","title":"Binary Exponentiation","text":"<ul> <li>(cp-algorithms) Binary Exponentiation</li> <li>C\u00f3digo de ejemplo</li> </ul>"},{"location":"resources/math/#conteo-y-combinatoria-modular","title":"Conteo y Combinatoria modular","text":"<ul> <li>Muy buen art\u00edculo sobre distintos m\u00e9todos para calcular combinatorias</li> <li>Modular Binomial Coefficient (Choose(n,k) mod X): c\u00f3digo de ejemplo</li> <li>Modular Multinomial Coefficient: c\u00f3digo de ejemplo</li> </ul>"},{"location":"resources/math/#algoritmo-de-euclides","title":"Algoritmo de Euclides","text":"<p>c\u00f3mo encontrar el GCD entre dos n\u00fameros</p> <ul> <li>(youtube) Euclidean Algorithm (Proof)</li> <li>(youtube) Number Theory: Euclidean Algorithm - An example</li> <li>(cp-algorithms) Euclidean algorithm for computing the greatest common divisor</li> <li>(youtube) (Discrete Math 1) Euclidian Algorithm</li> <li>Euclidean Algorithm \u2013 Greatest Common Divisor</li> <li>(geeksforgeeks) std::gcd | C++ inbuilt function for finding GCD</li> </ul> <p>LCM (m\u00ednimo com\u00fan m\u00faltiplo): https://cp-algorithms.com/algebra/euclid-algorithm.html (revisar final de la p\u00e1gina)</p>"},{"location":"resources/math/#algoritmo-de-euclides-extendido-gcdext","title":"Algoritmo de Euclides Extendido (gcdext)","text":"<ul> <li>https://forthright48.com/extended-euclidean-algorithm/</li> <li>(cp-algorithms) Extended Euclidean Algorithm</li> <li>(math.stackexchange) gcdext con n\u00fameros negativos?</li> <li>(youtube) Algoritmo de Euclides [ICPCCL 2016]</li> <li>(youtube) The Extended Euclidean algorithm</li> <li> <p>c\u00f3digo de ejemplo</p> </li> <li> </li> <li> </li> <li> </li> <li> </li> <li>C\u00f3digos de ejemplos</li> </ul>"},{"location":"resources/math/#aplicaciones-de-euclides-extendido","title":"Aplicaciones de Euclides Extendido","text":""},{"location":"resources/math/#modular-inverse","title":"Modular Inverse","text":"<ul> <li>(cp-algorithms) modular inverse</li> </ul>"},{"location":"resources/math/#linear-diophantine-equations","title":"Linear Diophantine Equations","text":"<ul> <li>(cp-algorithms) linear dophantine equation</li> <li>(youtube) N1--Introduction to Linear Diophantine Equations</li> <li>(youtube) N2--Solve Basic Linear Diophantine Equation</li> <li>(youtube) Number Theory: Diophantine Equation: ax+by=gcd(a,b)</li> <li>(PDF) http://gauss.math.luc.edu/greicius/Math201/Fall2012/Lectures/linear-diophantine.article.pdf</li> <li>http://mathonline.wikidot.com/solutions-to-linear-diophantine-equations</li> </ul>"},{"location":"resources/math/#linear-congruence-equation","title":"Linear Congruence Equation","text":"<ul> <li>(cp-algorithms) Linear Congruence Equation</li> <li>(PDF) http://gauss.math.luc.edu/greicius/Math201/Fall2012/Lectures/linear-congruences.article.pdf</li> </ul>"},{"location":"resources/math/#chinese-remainder-theorem-crt","title":"Chinese Remainder Theorem (CRT)","text":"<ul> <li>(codeforces) [Tutorial] Chinese Remainder Theorem</li> <li>(youtube) The Chinese Remainder Theorem made easy</li> <li>(youtube) Chinese Remainder Theorem</li> <li>Chinese Remainder Theorem Part 1 \u2013 Coprime Moduli</li> <li>Chinese Remainder Theorem Part 2 \u2013 Non Coprime Moduli</li> <li>c\u00f3digo de ejemplo</li> </ul>"},{"location":"resources/math/#lucass-theorem","title":"Lucas's theorem","text":"<ul> <li>wikipedia - Lucas's theorem</li> <li>choose(n,k) mod M using Chinese remainder theorem? </li> </ul>"},{"location":"resources/math/#eulers-theorem-eulers-totient-function","title":"Euler's Theorem &amp; Euler's Totient Function","text":"<ul> <li>wikipedia - Euler's Theorem</li> <li>wikipedia - Euler's Totient Function</li> <li>cp-algorithms: Euler's Totient Function</li> </ul>"},{"location":"resources/math/#integracion-numerica","title":"Integraci\u00f3n Num\u00e9rica","text":"<ul> <li>(Wikipedia) https://en.wikipedia.org/wiki/Numerical_integration</li> <li>(Codeforces Tasks involving numerical integration</li> <li>(youtube) Explanation of Simpson's rule | MIT 18.01SC Single Variable Calculus, Fall 2010</li> <li>(youtube) Simpson's Rule &amp; Numerical Integration</li> <li>(youtube) Numerical Integration With Trapezoidal and Simpson's Rule</li> </ul>"},{"location":"resources/search/","title":"(Bi|Ter)nary Search","text":""},{"location":"resources/search/#binary-search","title":"Binary Search","text":"<ul> <li>Youtube - Excelente video explicando binary search (RECOMENDADO)</li> <li>Youtube - muy buena comparaci\u00f3n entre linear search y binary search (+ c\u00f3digo)</li> <li>Youtube - Algorithms: Binary Search</li> <li>http://progcomp.cl/binarysearch</li> <li>Ejemplo de implementaci\u00f3n en C++</li> <li>geeksforgeeks - Binary Search functions in C++ STL (binary_search, lower_bound and upper_bound)</li> <li>caso especial: binary search on doubles - codeforces cuando el problema es continuo (no-discreto)</li> </ul>"},{"location":"resources/search/#ternary-search","title":"Ternary Search","text":"<ul> <li>https://www.hackerearth.com/practice/algorithms/searching/ternary-search/tutorial/</li> <li>https://en.wikipedia.org/wiki/Ternary_search</li> <li>https://github.com/PabloMessina/Competitive-Programming-Material/blob/master/Search/TernarySearch.cpp</li> <li>C\u00f3mo reducir Ternary Search a Binary Search: Codeforces - The great ternary search hoax</li> </ul>"},{"location":"resources/sqrtdecomp/","title":"Square Root Decomposition","text":"<ul> <li>cp-algorithms: square decomposition</li> <li>Mo's Algorithm:</li> <li>cp-algorhtms: Mo's algorithm</li> <li>geeksforgeeks: Mo's algorithm (query square root decomposition)</li> <li>geeksforgeeks: extended Mo's algorithm (O(1) time complexity)</li> </ul>"},{"location":"resources/strings/","title":"Strings","text":""},{"location":"resources/strings/#suffix-automaton","title":"Suffix Automaton","text":"<ul> <li>codeforces - A short guide to suffix automata</li> <li>https://cp-algorithms.com/string/suffix-automaton.html</li> <li>youtube - Suffix Automation Explanation</li> </ul>"},{"location":"resources/strings/#suffix-array","title":"Suffix Array","text":"<ul> <li>\u00bfQu\u00e9 es un suffix array?: Youtube - Suffix Array introduction</li> <li>Motivaci\u00f3n para Suffix Arrays: Youtube - 35 6 Suffix Arrays</li> <li>C\u00f3mo construir un Suffix Array eficientemente:</li> <li>Youtube - Construction of suffix arrays</li> <li>https://www.cs.helsinki.fi/u/tpkarkka/opetus/10s/spa/lecture11.pdf</li> <li>HackerRank - Suffix Array</li> <li>cp-algorithms: Suffix Array</li> <li>Longest Common Prefix (LCP):</li> <li>Youtube - Longest Common Prefix (LCP) array</li> <li>Codeforces - LCP from suffix array</li> <li>geeksforgeeks - kasai\u2019s Algorithm for Construction of LCP array from Suffix Array</li> <li>C\u00f3digos de Ejemplo:</li> <li>suffix_array.cpp</li> <li>Codeforces - Suffix Arrays</li> </ul>"},{"location":"resources/strings/#kmp-string-pattern-matching","title":"KMP (String Pattern Matching)","text":"<ul> <li>youtube: KMP String matching algorithm</li> <li>youtube: KMP Searching Algorithm</li> <li>youtube: 9.1 Knuth-Morris-Pratt KMP String Matching Algorithm</li> <li>youtube: Knuth\u2013Morris\u2013Pratt(KMP) Pattern Matching(Substring search)</li> <li>youtube: Knuth\u2013Morris\u2013Pratt(KMP) Pattern Matching(Substring search) Part2</li> <li>cp-algorithms: KMP</li> <li>c\u00f3digo de ejemplo</li> <li>Shortest Repeating Cycle<ul> <li>http://www.geeksforgeeks.org/find-given-string-can-represented-substring-iterating-substring-n-times/</li> <li>http://stackoverflow.com/questions/6021274/finding-shortest-repeating-cycle-in-word</li> <li>c\u00f3digo de ejemplo</li> </ul> </li> </ul>"},{"location":"resources/strings/#trie","title":"Trie","text":"<ul> <li>https://en.wikipedia.org/wiki/Trie</li> <li>youtube - Data Structures: Tries</li> <li>youtube - Trie Data Structure</li> <li>C\u00f3digo de ejemplo</li> </ul>"},{"location":"resources/strings/#rolling-hashing","title":"Rolling Hashing","text":"<ul> <li>https://progcomp.cl/rollinghashing</li> <li>cp-algorithms: String Hashing</li> <li>c\u00f3digo de ejemplo</li> </ul>"},{"location":"resources/cpp/","title":"C++","text":"Ejemplo de Hello World<pre><code>#include &lt;bits/stdc++.h&gt; //importa todo\nusing namespace std; //para no escribir std::\nint main()\n{\nprintf(\"Hello world\\n\"); //Usando syntax de C\ncout &lt;&lt; \"Hello world\\n\"; //Usando streams de C++\nreturn 0;\n}\n</code></pre> Ejemplo de Template<pre><code>#pragma GCC optimize(\"Ofast\")\n#include &lt;bits/stdc++.h&gt;\nusing namespace std;\n// defines\n#define rep(i,a,b) for(int i = a; i &lt; b; ++i)\n#define invrep(i,b,a) for(int i = b; i &gt;= a; --i)\n#define umap unordered_map\n#define uset unordered_set\n#define ff first\n#define ss second\n// typedefs\ntypedef pair&lt;int,int&gt; ii;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\n// -------------------------------\nint main() {\nios::sync_with_stdio(false); cin.tie(0);\nreturn 0;\n}\n</code></pre>"},{"location":"resources/cpp/#instalando-c","title":"Instalando C++","text":"<ul> <li>Windows:<ul> <li>Usando GCC con MinGW</li> <li>MSYS2</li> </ul> </li> <li>Linux:<ul> <li>Debian o Ubuntu (apt)     Usar el comando<pre><code>    sudo apt-get install g++\n</code></pre></li> <li>Arch Linux (pacman)     Usar el comando<pre><code>    sudo pacman -S g++\n</code></pre></li> <li>CentOS, Fedora, o RHEL (yum)     Usar el comando<pre><code>    sudo yum install gcc-c++\n</code></pre> Compilar con g++</li> </ul> </li> <li>Mac:<ul> <li>Installer en OSX</li> <li>Compilar con CLang</li> </ul> </li> </ul>"},{"location":"resources/cpp/#compilando-y-ejecutando-codigo-en-c","title":"Compilando y ejecutando c\u00f3digo en C++:","text":"<p>Ejemplo de secuencia de pasos para resolver un problema en C++ en Windows usando la terminal (en Linux/Mac es bien parecido):</p> <ul> <li>Crear un archivo <code>example.cpp</code></li> <li>Escribir un c\u00f3digo de C++ v\u00e1lido y guardar.</li> <li>Abrir una terminal y navegar a la carpeta donde est\u00e1 el archivo.</li> <li>Opci\u00f3n 1:<ul> <li>En la terminal, compilar y ejecutar con el comando:  <pre><code>    g++ -std=c++11 example.cpp &amp;&amp; a.exe\n</code></pre></li> <li>Escribir el input directamente en la terminal</li> <li>El output ir\u00e1 apareciendo poco a poco en la terminal (intercalado con el input)</li> </ul> </li> <li>Opci\u00f3n 2:<ul> <li>Crear un archivo en la carpeta donde est\u00e1n parados llamado input.txt, copiar y pegar el input ah\u00ed y guardar.</li> <li>En la terminal, compilar y ejecutar con el comando:  <pre><code>    g++ -std=c++11 example.cpp &amp;&amp; a.exe &lt; input.txt\n</code></pre></li> <li>el output aparecer\u00e1 en la misma terminal</li> </ul> </li> <li>Opci\u00f3n 3:<ul> <li>Crear un archivo en la carpeta donde est\u00e1n parados llamado input.txt, copiar y pegar el input ah\u00ed y guardar.</li> <li>En la terminal, compilar y ejecutar con el comando:  <pre><code>    g++ -std=c++11 example.cpp &amp;&amp; a.exe &lt; input.txt &gt; output.txt\n</code></pre></li> <li>el output quedar\u00e1 guardado en el archivo <code>output.txt</code>.</li> </ul> </li> </ul>"},{"location":"resources/cpp/#tutoriales-para-aprender-c","title":"Tutoriales para aprender C++","text":"<ul> <li>(youtube) Intro a la Programaci\u00f3n Competitiva en C++ (&lt;&lt;&lt;&lt; video cortito, recomendado)</li> <li>C++ for Python Programmers (&lt;&lt;&lt;&lt; por si vienes de Python)</li> <li>C++ Tutorial (SOLO LEARN: EVERYONE CAN CODE)</li> <li>http://www.cplusplus.com/doc/tutorial/</li> <li>https://www.hackerrank.com/domains/cpp</li> <li>LearnCpp</li> <li>Documentaci\u00f3n Oficial de C++</li> <li>(youtube) Intro a C++</li> <li>(youtube) Estructuras b\u00e1sicas en C++</li> <li>(youtube) C++ Programming Video Tutorials For Beginners [ Complete Series ]</li> <li>INPUT / OUTPUT:<ul> <li>Yet again on C++ input/output</li> <li>\u00bfQu\u00e9 es mejor para leer input / imprimir output? cin/cout vs printf/scanf</li> </ul> </li> </ul>"},{"location":"resources/cpp/#tips-de-implementacion-en-c-muy-utiles-en-progcomp","title":"Tips de implementaci\u00f3n en C++ (muy \u00fatiles en progcomp)","text":"<ul> <li>Cosas \u00fatiles que deber\u00edan saber de C++11 (PARA ESCRIBIR C\u00d3DIGOS M\u00c1S CORTOS Y ELEGANTES):<ul> <li>Tutorial: C++11 for programming contests</li> <li>Learn C++ 11 in 20 Minutes - Part I</li> <li>Learn C++ 11 in 20 Minutes - Part II</li> </ul> </li> <li> <p>Los beneficios de usar references (&amp;) y pointers (*) (para no copiar todo por valor y as\u00ed ser m\u00e1s eficientes):</p> <ul> <li>Diferencia entre references y pointers explicada (&lt;&lt;&lt;&lt; muy buen art\u00edculo, 100% recomendado)</li> <li>geeksforgeeks - Passing vector to a function in C++</li> <li>geeksforgeeks - When do we pass arguments by reference or pointer? </li> </ul> </li> <li> <p>Codeforces - Manejo de Strings en C++ (buenos tips para cuando tienen que leer input)</p> </li> <li>Youtube playlist: lista exhaustiva de videos cubriendo much\u00edsimos aspectos de C++</li> <li>STL: standard template library (buen material sobre la standard library de C++, MUY RECOMENDADO)<ul> <li>Introduction of STL #1: Overview</li> <li>Introduction of STL #2: Sequence Containers</li> <li>Introduction of STL #3: Associative Containers</li> <li>Introduction of STL #4: Unordered Containers</li> <li>Introduction of STL #5: Iterators and Algorithms</li> <li>Introduction of STL #6: Functors</li> <li>Topcoder: power up c++ with the standard template library part 1</li> <li>Topcoder: power up c++ with the standard template library part 2</li> <li>Youtube playlist: varios algoritmos de la librer\u00eda est\u00e1ndar de C++ para llegar y usar</li> </ul> </li> <li>Para aprender a trabajar con bits (operaciones bitwise):<ul> <li>Tutorial sobre Bitwise Operators</li> <li>\u00bfQu\u00e9 es bit masking?</li> <li>geeksforgeeks - Bitwise hacks for competitive programming</li> <li>geeksforgeeks - Bit Tricks for competitive programming</li> </ul> </li> <li>\u00bfQu\u00e9 son y para qu\u00e9 sirven Structs y Classes en C++?<ul> <li>Advanced C++: Struct Vs. Class</li> <li>Introduction to Structures in C++ CPP Programming Video Tutorial</li> <li>Buckys C++ Programming Tutorials - 12 - Introduction to Classes and Objects</li> <li>Structure and Class differences in C++ C ++ Tutorial Mr. Kishore</li> <li>CLASSES vs STRUCTS in C++</li> </ul> </li> </ul>"},{"location":"resources/cpp/#c-cheat-sheets-tricks","title":"C++ Cheat Sheets &amp; Tricks:","text":"<ul> <li>C++ Cheat Sheet for ACM ICPC <ul> <li>Aqu\u00ed pueden encontrar un C++ Solution Template (c\u00f3digo que uno siempre escribe al comenzar una soluci\u00f3n) + MUCHO MUCHO m\u00e1s :)</li> </ul> </li> <li>C++ STL cheatsheet for competitive programming</li> <li>C++ Tricks</li> <li>C++ tricks for competitive programming (for C++ 11)</li> <li>C++ Cheat Sheet de Pablo Messina</li> </ul>"},{"location":"resources/cpp/cpp_osx/","title":"Compiladores de C++ para OSX","text":""},{"location":"resources/cpp/cpp_osx/#default","title":"Default","text":"<p>OSX en general ya tiene instalado g++ y clang, esto se puede revisar haciendo lo siguiente en alg\u00fan terminal <code>which g++</code> con lo cual deber\u00eda salir <code>/usr/bin/g++</code>. Igualmente con clang, <code>which clang</code> y deber\u00eda salir <code>/usr/bin/clang</code></p>"},{"location":"resources/cpp/cpp_osx/#usando-brew","title":"Usando Brew","text":""},{"location":"resources/cpp/cpp_osx/#que-es-brew","title":"\u00bfQu\u00e9 es Brew?","text":"<p>Brew es un packet manager para OSX, es f\u00e1cil de usar. Su p\u00e1gina es esta.</p>"},{"location":"resources/cpp/cpp_osx/#instalar-g","title":"Instalar g++","text":"<p>Cuando uno quiere instalar g++ uno busca gcc <pre><code>brew search gcc\n</code></pre> Con esto aparecen varias opciones, por ejemplo <code>gcc@7</code>. Para instalarlo se usa <pre><code>brew install gcc@7\n</code></pre> Y una vez instalado uno lo usa de la siguiente forma <pre><code>g++-7 input_file.cpp\n</code></pre></p>"}]}